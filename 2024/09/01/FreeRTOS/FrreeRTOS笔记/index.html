<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>FreeRTOS学习笔记 | 无限进步</title><meta name="author" content="WangTao"><meta name="copyright" content="WangTao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、FreeRTOS源码概述1、入口函数在Core\Src\main.c的main函数里，初始化了FreeRTOS环境、创建了任务，然后启动调度器。源码如下： 123456&#x2F;* Init scheduler *&#x2F;  osKernelInitialize();  &#x2F;* 初始化FreeRTOS运行环境 *&#x2F;  MX_FREERTOS_Init();    &#x2F;* 创建任务 *&#x2F;  &#x2F;* Start sc">
<meta property="og:type" content="article">
<meta property="og:title" content="FreeRTOS学习笔记">
<meta property="og:url" content="http://example.com/2024/09/01/FreeRTOS/FrreeRTOS%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="无限进步">
<meta property="og:description" content="一、FreeRTOS源码概述1、入口函数在Core\Src\main.c的main函数里，初始化了FreeRTOS环境、创建了任务，然后启动调度器。源码如下： 123456&#x2F;* Init scheduler *&#x2F;  osKernelInitialize();  &#x2F;* 初始化FreeRTOS运行环境 *&#x2F;  MX_FREERTOS_Init();    &#x2F;* 创建任务 *&#x2F;  &#x2F;* Start sc">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic1.imgdb.cn/item/67dfb24188c538a9b5c50a54.jpg">
<meta property="article:published_time" content="2024-08-31T16:00:00.000Z">
<meta property="article:modified_time" content="2024-09-24T07:12:04.758Z">
<meta property="article:author" content="WangTao">
<meta property="article:tag" content="FreeRTOS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic1.imgdb.cn/item/67dfb24188c538a9b5c50a54.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "FreeRTOS学习笔记",
  "url": "http://example.com/2024/09/01/FreeRTOS/FrreeRTOS%E7%AC%94%E8%AE%B0/",
  "image": "https://pic1.imgdb.cn/item/67dfb24188c538a9b5c50a54.jpg",
  "datePublished": "2024-08-31T16:00:00.000Z",
  "dateModified": "2024-09-24T07:12:04.758Z",
  "author": [
    {
      "@type": "Person",
      "name": "WangTao",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="https://pic.imgdb.cn/item/63aa8d0308b683016356202d.png"><link rel="canonical" href="http://example.com/2024/09/01/FreeRTOS/FrreeRTOS%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'FreeRTOS学习笔记',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(https://pic1.imgdb.cn/item/63a83a5408b68301634bd72b.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://pic1.imgdb.cn/item/67dfb24188c538a9b5c50a54.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/Categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tag"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: transparent;"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">无限进步</span></a><a class="nav-page-title" href="/"><span class="site-name">FreeRTOS学习笔记</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/Categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tag"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">FreeRTOS学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-08-31T16:00:00.000Z" title="发表于 2024-09-01 00:00:00">2024-09-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-09-24T07:12:04.758Z" title="更新于 2024-09-24 15:12:04">2024-09-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/FreeRTOS/">FreeRTOS</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">2.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>8分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="一、FreeRTOS源码概述"><a href="#一、FreeRTOS源码概述" class="headerlink" title="一、FreeRTOS源码概述"></a>一、FreeRTOS源码概述</h1><h3 id="1、入口函数"><a href="#1、入口函数" class="headerlink" title="1、入口函数"></a>1、入口函数</h3><p>在Core\Src\main.c的main函数里，初始化了FreeRTOS环境、创建了任务，然后启动调度器。源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Init scheduler */</span></span><br><span class="line">  osKernelInitialize();  <span class="comment">/* 初始化FreeRTOS运行环境 */</span></span><br><span class="line">  MX_FREERTOS_Init();    <span class="comment">/* 创建任务 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Start scheduler */</span></span><br><span class="line">  osKernelStart();       <span class="comment">/* 启动调度器 */</span></span><br></pre></td></tr></table></figure>

<h3 id="2、数据类型"><a href="#2、数据类型" class="headerlink" title="2、数据类型"></a>2、数据类型</h3><p>每个移植的版本都含有自己的portmacro.h头文件，里面定义了2个数据类型：</p>
<ul>
<li>TickType_t：<ul>
<li>FreeRTOS配置了一个周期性的时钟中断：Tick Interrupt</li>
<li>每发生一次中断，中断次数累加，这被称为tick count</li>
<li>tick count这个变量的类型就是TickType_t</li>
<li>TickType_t可以是16位的，也可以是32位的</li>
<li>FreeRTOSConfig.h中定义configUSE_16_BIT_TICKS时，TickType_t就是uint16_t，否则TickType_t就是uint32_t</li>
<li>对于32位架构，建议把TickType_t配置为uint32_t</li>
</ul>
</li>
<li>BaseType_t：<ul>
<li>这是该架构最高效的数据类型</li>
<li>32位架构中，它就是uint32_t</li>
<li>16位架构中，它就是uint16_t</li>
<li>8位架构中，它就是uint8_t</li>
<li>BaseType_t通常用作简单的返回值的类型，还有逻辑值，比如pdTRUE&#x2F;pdFALSE</li>
</ul>
</li>
</ul>
<h3 id="3、变量名"><a href="#3、变量名" class="headerlink" title="3、变量名"></a>3、变量名</h3><img src="C:\Users\WangTao\AppData\Roaming\Typora\typora-user-images\image-20240913132816742.png" alt="image-20240913132816742" style="zoom: 67%;" />

<h3 id="4、函数名"><a href="#4、函数名" class="headerlink" title="4、函数名"></a>4、函数名</h3><img src="C:\Users\WangTao\AppData\Roaming\Typora\typora-user-images\image-20240913132943307.png" alt="image-20240913132943307" style="zoom:67%;" />

<h1 id="二、内存管理"><a href="#二、内存管理" class="headerlink" title="二、内存管理"></a>二、内存管理</h1><h3 id="1、堆和栈"><a href="#1、堆和栈" class="headerlink" title="1、堆和栈"></a>1、堆和栈</h3><ul>
<li>堆，heap，就是一块空闲的内存，需要提供管理函数<ul>
<li>malloc：从堆里划出一块空间给程序使用</li>
<li>free：用完后，再把它标记为”空闲”的，可以再次使用</li>
</ul>
</li>
<li>栈，stack，函数调用时局部变量保存在栈中，当前程序的环境也是保存在栈中<ul>
<li>可以从堆中分配一块空间用作栈</li>
</ul>
</li>
</ul>
<img src="C:\Users\WangTao\AppData\Roaming\Typora\typora-user-images\image-20240913133522988.png" alt="image-20240913133522988" style="zoom:50%;" />

<h3 id="2、Heap相关的函数"><a href="#2、Heap相关的函数" class="headerlink" title="2、Heap相关的函数"></a>2、Heap相关的函数</h3><p><strong>pvPortMalloc&#x2F;vPortFree</strong></p>
<p>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> * <span class="title function_">pvPortMalloc</span><span class="params">( <span class="type">size_t</span> xWantedSize )</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">vPortFree</span><span class="params">( <span class="type">void</span> * pv )</span>;</span><br></pre></td></tr></table></figure>

<p>作用：分配内存、释放内存。</p>
<p>如果分配内存不成功，则返回值为NULL。</p>
<hr>
<p><strong>xPortGetFreeHeapSize</strong></p>
<p>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">xPortGetFreeHeapSize</span><span class="params">( <span class="type">void</span> )</span>;</span><br></pre></td></tr></table></figure>

<p>当前还有多少空闲内存，这函数可以用来优化内存的使用情况。比如当所有内核对象都分配好后，执行此函数返回2000，那么configTOTAL_HEAP_SIZE就可减小2000。</p>
<p>注意：在heap_3中无法使用。</p>
<hr>
<p><strong>xPortGetMinimumEverFreeHeapSize</strong></p>
<p>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">xPortGetMinimumEverFreeHeapSize</span><span class="params">( <span class="type">void</span> )</span>;</span><br></pre></td></tr></table></figure>

<p>返回：程序运行过程中，空闲内存容量的最小值。</p>
<p>注意：只有heap_4、heap_5支持此函数</p>
<h1 id="三、任务管理"><a href="#三、任务管理" class="headerlink" title="三、任务管理"></a>三、任务管理</h1><h3 id="1、创建任务"><a href="#1、创建任务" class="headerlink" title="1、创建任务"></a>1、创建任务</h3><h4 id="1-1、示例："><a href="#1-1、示例：" class="headerlink" title="1.1、示例："></a>1.1、示例：</h4><p><strong>动态分配：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建句柄</span></span><br><span class="line">TaskHandle_t xSoundTaskHandle;</span><br><span class="line"><span class="comment">//接收返回值类型,应该没用到</span></span><br><span class="line">BaseType_t ret;</span><br><span class="line"><span class="comment">//创建任务函数</span></span><br><span class="line">ret = xTaskCreate(PlayMusic, <span class="string">&quot;SoundTask&quot;</span>, <span class="number">128</span>, <span class="literal">NULL</span>, osPriorityNormal, &amp;xSoundTaskHandle);</span><br></pre></td></tr></table></figure>

<p><strong>静态分配：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> StackType_t g_pucStackOfLEDTask[<span class="number">128</span>]; <span class="comment">//因为StackType_t的类型是32位，所以不需要*4</span></span><br><span class="line"><span class="type">static</span> StaticTask_t g_TCBofLEDTask;</span><br><span class="line"><span class="type">static</span> TaskHandle_t xLEDTaskHandle;</span><br><span class="line"><span class="comment">//创建任务函数</span></span><br><span class="line">xLEDTaskHandle = xTaskCreateStatic(led_test, <span class="string">&quot;LEDTask&quot;</span>, <span class="number">128</span>, <span class="literal">NULL</span>, osPriorityNormal, g_pucStackOfLEDTask, &amp;g_TCBofLEDTask);</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-2、函数解析"><a href="#1-2、函数解析" class="headerlink" title="1.2、函数解析"></a>1.2、函数解析</h4><p>创建任务时使用的函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskCreate</span><span class="params">( TaskFunction_t pxTaskCode, <span class="comment">// 函数指针, 任务函数</span></span></span><br><span class="line"><span class="params">                        <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName, <span class="comment">// 任务的名字</span></span></span><br><span class="line"><span class="params">                        <span class="type">const</span> configSTACK_DEPTH_TYPE usStackDepth, <span class="comment">// 栈大小,单位为word,10表示40字节</span></span></span><br><span class="line"><span class="params">                        <span class="type">void</span> * <span class="type">const</span> pvParameters, <span class="comment">// 调用任务函数时传入的参数</span></span></span><br><span class="line"><span class="params">                        UBaseType_t uxPriority,    <span class="comment">// 优先级</span></span></span><br><span class="line"><span class="params">                        TaskHandle_t * <span class="type">const</span> pxCreatedTask )</span>; <span class="comment">// 任务句柄, 以后使用它来操作这个任务</span></span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>pvTaskCode</td>
<td>函数指针，任务对应的 C 函数。任务应该永远不退出，或者在退出时调用 “vTaskDelete(NULL)”。</td>
</tr>
<tr>
<td>pcName</td>
<td>任务的名称，仅用于调试目的，FreeRTOS 内部不使用。pcName 的长度为 configMAX_TASK_NAME_LEN。</td>
</tr>
<tr>
<td>usStackDepth</td>
<td>每个任务都有自己的栈，usStackDepth 指定了栈的大小，单位为 word。例如，如果传入 100，表示栈的大小为 100 word，即 400 字节。最大值为 uint16_t 的最大值。确定栈的大小并不容易，通常是根据估计来设定。精确的办法是查看反汇编代码。</td>
</tr>
<tr>
<td>pvParameters</td>
<td>调用 pvTaskCode 函数指针时使用的参数：pvTaskCode(pvParameters)。</td>
</tr>
<tr>
<td>uxPriority</td>
<td>任务的优先级范围为 0~(configMAX_PRIORITIES – 1)。数值越小，优先级越低。如果传入的值过大，xTaskCreate 会将其调整为 (configMAX_PRIORITIES – 1)。</td>
</tr>
<tr>
<td>pxCreatedTask</td>
<td>用于保存 xTaskCreate 的输出结果，即任务的句柄（task handle）。如果以后需要对该任务进行操作，如修改优先级，则需要使用此句柄。如果不需要使用该句柄，可以传入 NULL。</td>
</tr>
<tr>
<td>返回值</td>
<td>成功时返回 pdPASS，失败时返回 errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY（失败原因是内存不足）。请注意，文档中提到的失败返回值是 pdFAIL 是不正确的。pdFAIL 的值为 0，而 errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY 的值为 -1。</td>
</tr>
</tbody></table>
<p>使用静态分配内存的函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TaskHandle_t <span class="title function_">xTaskCreateStatic</span> <span class="params">( </span></span><br><span class="line"><span class="params">    TaskFunction_t pxTaskCode,   <span class="comment">// 函数指针, 任务函数</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName,   <span class="comment">// 任务的名字</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">uint32_t</span> ulStackDepth, <span class="comment">// 栈大小,单位为word,10表示40字节</span></span></span><br><span class="line"><span class="params">    <span class="type">void</span> * <span class="type">const</span> pvParameters,   <span class="comment">// 调用任务函数时传入的参数</span></span></span><br><span class="line"><span class="params">    UBaseType_t uxPriority,      <span class="comment">// 优先级</span></span></span><br><span class="line"><span class="params">    StackType_t * <span class="type">const</span> puxStackBuffer, <span class="comment">// 静态分配的栈，就是一个buffer</span></span></span><br><span class="line"><span class="params">    StaticTask_t * <span class="type">const</span> pxTaskBuffer <span class="comment">// 静态分配的任务结构体的指针，用它来操作这个任务</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>相比于使用动态分配内存创建任务的函数，最后2个参数不一样：</p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>pvTaskCode</td>
<td>函数指针，可以简单地认为任务就是一个C函数。 它稍微特殊一点：永远不退出，或者退出时要调用”vTaskDelete(NULL)”</td>
</tr>
<tr>
<td>pcName</td>
<td>任务的名字，FreeRTOS内部不使用它，仅仅起调试作用。 长度为：configMAX_TASK_NAME_LEN</td>
</tr>
<tr>
<td>usStackDepth</td>
<td>每个任务都有自己的栈，这里指定栈大小。 单位是word，比如传入100，表示栈大小为100 word，也就是400字节。 最大值为uint16_t的最大值。 怎么确定栈的大小，并不容易，很多时候是估计。 精确的办法是看反汇编码。</td>
</tr>
<tr>
<td>pvParameters</td>
<td>调用pvTaskCode函数指针时用到：pvTaskCode(pvParameters)</td>
</tr>
<tr>
<td>uxPriority</td>
<td>优先级范围：0~(configMAX_PRIORITIES – 1) 数值越小优先级越低， 如果传入过大的值，xTaskCreate会把它调整为(configMAX_PRIORITIES – 1)</td>
</tr>
<tr>
<td>puxStackBuffer</td>
<td>静态分配的栈内存，比如可以传入一个数组， 它的大小是usStackDepth*4。</td>
</tr>
<tr>
<td>pxTaskBuffer</td>
<td>静态分配的StaticTask_t结构体的指针</td>
</tr>
<tr>
<td>返回值</td>
<td>成功：返回任务句柄； 失败：NULL</td>
</tr>
</tbody></table>
<h4 id="1-3、使用任务参数"><a href="#1-3、使用任务参数" class="headerlink" title="1.3、使用任务参数"></a>1.3、使用任务参数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* 使用同一个函数创建不同的任务 */</span><br><span class="line">  xTaskCreate(LcdPrintTask, <span class="string">&quot;task1&quot;</span>, <span class="number">128</span>, &amp;g_Task1Info, osPriorityNormal, <span class="literal">NULL</span>);</span><br><span class="line">  xTaskCreate(LcdPrintTask, <span class="string">&quot;task2&quot;</span>, <span class="number">128</span>, &amp;g_Task2Info, osPriorityNormal, <span class="literal">NULL</span>);</span><br><span class="line">  xTaskCreate(LcdPrintTask, <span class="string">&quot;task3&quot;</span>, <span class="number">128</span>, &amp;g_Task3Info, osPriorityNormal, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<h3 id="2、任务的删除"><a href="#2、任务的删除" class="headerlink" title="2、任务的删除"></a>2、任务的删除</h3><h4 id="2-1、示例："><a href="#2-1、示例：" class="headerlink" title="2.1、示例："></a>2.1、示例：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除任务，传入句柄</span></span><br><span class="line">vTaskDelete(xSoundTaskHandle);</span><br></pre></td></tr></table></figure>

<h4 id="2-2、函数解析："><a href="#2-2、函数解析：" class="headerlink" title="2.2、函数解析："></a>2.2、函数解析：</h4><p>删除任务时使用的函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelete</span><span class="params">( TaskHandle_t xTaskToDelete )</span>;</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>pvTaskCode</td>
<td>任务句柄，使用xTaskCreate创建任务时可以得到一个句柄。 也可传入NULL，这表示删除自己。</td>
</tr>
</tbody></table>
<p>怎么删除任务？举个不好的例子：</p>
<ul>
<li>自杀：vTaskDelete(NULL)</li>
<li>被杀：别的任务执行vTaskDelete(pvTaskCode)，pvTaskCode是自己的句柄</li>
<li>杀人：执行vTaskDelete(pvTaskCode)，pvTaskCode是别的任务的句柄</li>
</ul>
<h3 id="3、优先级和Tick"><a href="#3、优先级和Tick" class="headerlink" title="3、优先级和Tick"></a>3、优先级和Tick</h3><ul>
<li>FreeRTOS会确保最高优先级的、可运行的任务，马上就能执行</li>
<li>对于相同优先级的、可运行的任务，轮流执行</li>
<li>FreeRTOS中也有心跳，它使用定时器产生固定间隔的中断。这叫Tick、滴答，比如每10ms发生一次时钟中断。</li>
</ul>
<h4 id="3-1、优先级实验"><a href="#3-1、优先级实验" class="headerlink" title="3.1、优先级实验"></a>3.1、优先级实验</h4><p>提高音乐播放任务的优先级，使用vTaskDelay进行延时。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改优先级，+1</span></span><br><span class="line">ret = xTaskCreate(PlayMusic, <span class="string">&quot;SoundTask&quot;</span>, <span class="number">128</span>, <span class="literal">NULL</span>, osPriorityNormal+<span class="number">1</span>, &amp;xSoundTaskHandle);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在music.h里面，要修改HAL_Delay，不然会一直执行优先级高的任务，而其他的任务不执行，造成阻塞</span></span><br><span class="line">vTaskDelay(MusicSpeed/Music_Lone_Brave[i][<span class="number">2</span>]);  <span class="comment">//vTaskDelay主动放弃cpu资源，并延时。而HAL_Delay不会主动</span></span><br></pre></td></tr></table></figure>

<h4 id="3-2、修改优先级"><a href="#3-2、修改优先级" class="headerlink" title="3.2、修改优先级"></a>3.2、修改优先级</h4><p>使用uxTaskPriorityGet来获得任务的优先级：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UBaseType_t <span class="title function_">uxTaskPriorityGet</span><span class="params">( <span class="type">const</span> TaskHandle_t xTask )</span>;</span><br></pre></td></tr></table></figure>

<p>使用参数xTask来指定任务，设置为NULL表示获取自己的优先级。</p>
<p>使用vTaskPrioritySet 来设置任务的优先级：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskPrioritySet</span><span class="params">( TaskHandle_t xTask,</span></span><br><span class="line"><span class="params">                       UBaseType_t uxNewPriority )</span>;</span><br></pre></td></tr></table></figure>

<p>使用参数xTask来指定任务，设置为NULL表示获取自己的优先级。</p>
<p>使用vTaskPrioritySet 来设置任务的优先级：</p>
<h3 id="4、任务状态"><a href="#4、任务状态" class="headerlink" title="4、任务状态"></a>4、任务状态</h3><ul>
<li>运行(Runing)</li>
<li>阻塞状态(Blocked)</li>
<li>暂停状态(Suspended)</li>
<li>就绪状态(Ready)</li>
</ul>
<img src="C:\Users\WangTao\AppData\Roaming\Typora\typora-user-images\image-20240913142618916.png" alt="image-20240913142618916" style="zoom: 67%;" />

<p>链表任务调度流程：</p>
<p><img src="C:\Users\WangTao\AppData\Roaming\Typora\typora-user-images\image-20240913143620614.png" alt="image-20240913143620614"></p>
<h3 id="5、任务暂停与恢复"><a href="#5、任务暂停与恢复" class="headerlink" title="5、任务暂停与恢复"></a>5、任务暂停与恢复</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//任务暂停：</span></span><br><span class="line">vTaskSuspend(xSoundTaskHandle);</span><br><span class="line"><span class="comment">//任务恢复：</span></span><br><span class="line">vTaskResume(xSoundTaskHandle);</span><br></pre></td></tr></table></figure>

<h3 id="6、两个delay函数"><a href="#6、两个delay函数" class="headerlink" title="6、两个delay函数"></a>6、两个delay函数</h3><ul>
<li>vTaskDelay：至少等待指定个数的Tick Interrupt才能变为就绪状态</li>
<li>vTaskDelayUntil：等待到指定的绝对时刻，才能变为就绪态；可以让任务周期性运行。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//延时500ms</span></span><br><span class="line">vTaskDelay(<span class="number">500</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取当前时刻</span></span><br><span class="line">BaseType_t preTime;</span><br><span class="line">preTime = xTaskGetTickCount();</span><br><span class="line"><span class="comment">//延时的时间为：preTime+500</span></span><br><span class="line">vTaskDelayUntil(&amp;preTime, <span class="number">500</span>);</span><br></pre></td></tr></table></figure>

<h1 id="四、同步与互斥"><a href="#四、同步与互斥" class="headerlink" title="四、同步与互斥"></a>四、同步与互斥</h1><h3 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h3><p>**同步：**哎哎哎，我正在用厕所，你等会。</p>
<p>**互斥：**哎哎哎，我正在用厕所，你不能进来。</p>
<p>**用“同步”来实现“互斥”：**我“等”你用完厕所，我再用厕所。</p>
<hr>
<p>假设有A、B两人早起抢厕所，A先行一步占用了；B慢了一步，于是就眯一会；当A用完后叫醒B，B也就愉快地上厕所了。</p>
<p>在这个过程中，A、B是互斥地访问“厕所”，“厕所”被称之为临界资源。我们使用了“休眠-唤醒”的同步机制实现了“临界资源”的“互斥访问”。</p>
<p>同一时间只能有一个人使用的资源，被称为临界资源。比如任务A、B都要使用串口来打印，串口就是临界资源。如果A、B同时使用串口，那么打印出来的信息就是A、B混杂，无法分辨。所以使用串口时，应该是这样：A用完，B再用；B用完，A再用。</p>
<h3 id="2、两个有缺陷的方法："><a href="#2、两个有缺陷的方法：" class="headerlink" title="2、两个有缺陷的方法："></a>2、<strong>两个有缺陷的方法：</strong></h3><p>1、使用标志位来进行判断任务A是否已经执行完毕，但是无法阻止任务B在判断的时候被切换出去，这时两个任务都满足条件，同时使用同一临界资源。</p>
<p>2、使用关中断，影响系统效率，影响其他进程运行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> bCanUse = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//关中断</span></span><br><span class="line">disable_irq();</span><br><span class="line">bCanUse--;</span><br><span class="line"><span class="comment">//执行完开中断</span></span><br><span class="line">enable_irq();</span><br></pre></td></tr></table></figure>

<h3 id="3、FreeRTOS提供的方法"><a href="#3、FreeRTOS提供的方法" class="headerlink" title="3、FreeRTOS提供的方法"></a>3、FreeRTOS提供的方法</h3></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">WangTao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/09/01/FreeRTOS/FrreeRTOS%E7%AC%94%E8%AE%B0/">http://example.com/2024/09/01/FreeRTOS/FrreeRTOS%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">无限进步</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/FreeRTOS/">FreeRTOS</a></div><div class="post-share"><div class="social-share" data-image="https://pic1.imgdb.cn/item/67dfb24188c538a9b5c50a54.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/04/10/STM32/C%E8%AF%AD%E8%A8%80/" title="C语言笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">C语言笔记</div></div><div class="info-2"><div class="info-item-1">一、从源代码到exe知识点： 从源代码到exe要经过五个时期，分别为预处理期、编译期、汇编期、连接期和执行期。在预处理期，就是程序员在编写代码的过程。编译期中编译器将源代码变为汇编语言，汇编语言是计算机语言的助记符号。汇编期中汇编器将汇编语言变为机器语言.obj，也就是计算机能够识别的01指令，机器最终执行的就是机器语言.obj，也称为目标文件。连接期就是将库函数（头文件）与所有的机器语言进行打包。最终在执行期将打包好的文件变为exe可执行文件。如果出现语法错误，那就是在编译期出现了编译错误。如果产生LNK连接错误就是在连接期出现了问题，可能是找不到头文件造成的，也可能是写错了main函数，或者在一个项目中没有或者出现多个main函数。 二、基本数据类型 知识点： 基本数据类型可以分为整型、字符型和浮点型三大类，其中整型包括short,int,long,long long 4小类；字符型包括char一个小类；浮点型包括float,double,long double 3小类。不同类型的字节数：char  1   short  2   int  4   long  4  ...</div></div></div></a><a class="pagination-related" href="/2025/03/23/hello-world/" title="Hello World"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Hello World</div></div><div class="info-2"><div class="info-item-1">Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot;  More info: Writing Run server1$ hexo server  More info: Server Generate static files1$ hexo generate  More info: Generating Deploy to remote sites1$ hexo deploy  More info: Deployment </div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://pic1.imgdb.cn/item/67dfb24188c538a9b5c50a54.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">WangTao</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://space.bilibili.com/449096702"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/18232290771" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="https://space.bilibili.com/449096702" target="_blank" title="Bilibili"><i class="fab fa-youtube" style="color: #24292e;"></i></a><a class="social-icon" href="https://pic.imgdb.cn/item/66f0ca68f21886ccc03a5df7.jpg" target="_blank" title="Wechat"><i class="fab fa-weixin" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">无线进步！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81FreeRTOS%E6%BA%90%E7%A0%81%E6%A6%82%E8%BF%B0"><span class="toc-text">一、FreeRTOS源码概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%85%A5%E5%8F%A3%E5%87%BD%E6%95%B0"><span class="toc-text">1、入口函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">2、数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%8F%98%E9%87%8F%E5%90%8D"><span class="toc-text">3、变量名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%87%BD%E6%95%B0%E5%90%8D"><span class="toc-text">4、函数名</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">二、内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%A0%86%E5%92%8C%E6%A0%88"><span class="toc-text">1、堆和栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81Heap%E7%9B%B8%E5%85%B3%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-text">2、Heap相关的函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86"><span class="toc-text">三、任务管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%88%9B%E5%BB%BA%E4%BB%BB%E5%8A%A1"><span class="toc-text">1、创建任务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1%E3%80%81%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-text">1.1、示例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2%E3%80%81%E5%87%BD%E6%95%B0%E8%A7%A3%E6%9E%90"><span class="toc-text">1.2、函数解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3%E3%80%81%E4%BD%BF%E7%94%A8%E4%BB%BB%E5%8A%A1%E5%8F%82%E6%95%B0"><span class="toc-text">1.3、使用任务参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%A0%E9%99%A4"><span class="toc-text">2、任务的删除</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1%E3%80%81%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-text">2.1、示例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2%E3%80%81%E5%87%BD%E6%95%B0%E8%A7%A3%E6%9E%90%EF%BC%9A"><span class="toc-text">2.2、函数解析：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8CTick"><span class="toc-text">3、优先级和Tick</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1%E3%80%81%E4%BC%98%E5%85%88%E7%BA%A7%E5%AE%9E%E9%AA%8C"><span class="toc-text">3.1、优先级实验</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2%E3%80%81%E4%BF%AE%E6%94%B9%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-text">3.2、修改优先级</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E4%BB%BB%E5%8A%A1%E7%8A%B6%E6%80%81"><span class="toc-text">4、任务状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E4%BB%BB%E5%8A%A1%E6%9A%82%E5%81%9C%E4%B8%8E%E6%81%A2%E5%A4%8D"><span class="toc-text">5、任务暂停与恢复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E4%B8%A4%E4%B8%AAdelay%E5%87%BD%E6%95%B0"><span class="toc-text">6、两个delay函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5"><span class="toc-text">四、同步与互斥</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%A6%82%E5%BF%B5"><span class="toc-text">1、概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%B8%A4%E4%B8%AA%E6%9C%89%E7%BC%BA%E9%99%B7%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-text">2、两个有缺陷的方法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81FreeRTOS%E6%8F%90%E4%BE%9B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">3、FreeRTOS提供的方法</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/23/hello-world/" title="Hello World">Hello World</a><time datetime="2025-03-23T05:33:20.044Z" title="发表于 2025-03-23 13:33:20">2025-03-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/01/FreeRTOS/FrreeRTOS%E7%AC%94%E8%AE%B0/" title="FreeRTOS学习笔记">FreeRTOS学习笔记</a><time datetime="2024-08-31T16:00:00.000Z" title="发表于 2024-09-01 00:00:00">2024-09-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/10/STM32/C%E8%AF%AD%E8%A8%80/" title="C语言笔记">C语言笔记</a><time datetime="2024-04-09T16:00:00.000Z" title="发表于 2024-04-10 00:00:00">2024-04-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/02/STM32/Flash%E9%97%AA%E5%AD%98/" title="Flash闪存笔记">Flash闪存笔记</a><time datetime="2023-11-01T16:00:00.000Z" title="发表于 2023-11-02 00:00:00">2023-11-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/20/STM32/WDG%E7%9C%8B%E9%97%A8%E7%8B%97/" title="WDG看门狗笔记">WDG看门狗笔记</a><time datetime="2023-10-20T00:00:00.000Z" title="发表于 2023-10-20 08:00:00">2023-10-20</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent;"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2025 By WangTao</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>