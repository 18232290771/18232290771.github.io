<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>FreeRTOS学习笔记 | 无限进步</title><meta name="author" content="WangTao"><meta name="copyright" content="WangTao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、FreeRTOS源码概述1、入口函数在Core\Src\main.c的main函数里，初始化了FreeRTOS环境、创建了任务，然后启动调度器。源码如下： 123456&#x2F;* Init scheduler *&#x2F;  osKernelInitialize();  &#x2F;* 初始化FreeRTOS运行环境 *&#x2F;  MX_FREERTOS_Init();    &#x2F;* 创建任务 *&#x2F;  &#x2F;* Start sc">
<meta property="og:type" content="article">
<meta property="og:title" content="FreeRTOS学习笔记">
<meta property="og:url" content="http://example.com/2024/09/01/FreeRTOS/FrreeRTOS%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="无限进步">
<meta property="og:description" content="一、FreeRTOS源码概述1、入口函数在Core\Src\main.c的main函数里，初始化了FreeRTOS环境、创建了任务，然后启动调度器。源码如下： 123456&#x2F;* Init scheduler *&#x2F;  osKernelInitialize();  &#x2F;* 初始化FreeRTOS运行环境 *&#x2F;  MX_FREERTOS_Init();    &#x2F;* 创建任务 *&#x2F;  &#x2F;* Start sc">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic1.imgdb.cn/item/63a83a5408b68301634bd72b.jpg">
<meta property="article:published_time" content="2024-08-31T16:00:00.000Z">
<meta property="article:modified_time" content="2025-03-23T13:16:13.743Z">
<meta property="article:author" content="WangTao">
<meta property="article:tag" content="FreeRTOS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic1.imgdb.cn/item/63a83a5408b68301634bd72b.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "FreeRTOS学习笔记",
  "url": "http://example.com/2024/09/01/FreeRTOS/FrreeRTOS%E7%AC%94%E8%AE%B0/",
  "image": "https://pic1.imgdb.cn/item/63a83a5408b68301634bd72b.jpg",
  "datePublished": "2024-08-31T16:00:00.000Z",
  "dateModified": "2025-03-23T13:16:13.743Z",
  "author": [
    {
      "@type": "Person",
      "name": "WangTao",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="https://pic.imgdb.cn/item/63aa8d0308b683016356202d.png"><link rel="canonical" href="http://example.com/2024/09/01/FreeRTOS/FrreeRTOS%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'FreeRTOS学习笔记',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(https://pic1.imgdb.cn/item/63a83a5408b68301634bd72b.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://pic1.imgdb.cn/item/67dfb24188c538a9b5c50a54.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tag"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://pic1.imgdb.cn/item/63a83a5408b68301634bd72b.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">无限进步</span></a><a class="nav-page-title" href="/"><span class="site-name">FreeRTOS学习笔记</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tag"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">FreeRTOS学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-08-31T16:00:00.000Z" title="发表于 2024-09-01 00:00:00">2024-09-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-23T13:16:13.743Z" title="更新于 2025-03-23 21:16:13">2025-03-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/FreeRTOS/">FreeRTOS</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">13k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>43分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="一、FreeRTOS源码概述"><a href="#一、FreeRTOS源码概述" class="headerlink" title="一、FreeRTOS源码概述"></a>一、FreeRTOS源码概述</h1><h3 id="1、入口函数"><a href="#1、入口函数" class="headerlink" title="1、入口函数"></a>1、入口函数</h3><p>在Core\Src\main.c的main函数里，初始化了FreeRTOS环境、创建了任务，然后启动调度器。源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Init scheduler */</span></span><br><span class="line">  osKernelInitialize();  <span class="comment">/* 初始化FreeRTOS运行环境 */</span></span><br><span class="line">  MX_FREERTOS_Init();    <span class="comment">/* 创建任务 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Start scheduler */</span></span><br><span class="line">  osKernelStart();       <span class="comment">/* 启动调度器 */</span></span><br></pre></td></tr></table></figure>

<h3 id="2、数据类型"><a href="#2、数据类型" class="headerlink" title="2、数据类型"></a>2、数据类型</h3><p>每个移植的版本都含有自己的portmacro.h头文件，里面定义了2个数据类型：</p>
<ul>
<li>TickType_t：<ul>
<li>FreeRTOS配置了一个周期性的时钟中断：Tick Interrupt</li>
<li>每发生一次中断，中断次数累加，这被称为tick count</li>
<li>tick count这个变量的类型就是TickType_t</li>
<li>TickType_t可以是16位的，也可以是32位的</li>
<li>FreeRTOSConfig.h中定义configUSE_16_BIT_TICKS时，TickType_t就是uint16_t，否则TickType_t就是uint32_t</li>
<li>对于32位架构，建议把TickType_t配置为uint32_t</li>
</ul>
</li>
<li>BaseType_t：<ul>
<li>这是该架构最高效的数据类型</li>
<li>32位架构中，它就是uint32_t</li>
<li>16位架构中，它就是uint16_t</li>
<li>8位架构中，它就是uint8_t</li>
<li>BaseType_t通常用作简单的返回值的类型，还有逻辑值，比如pdTRUE&#x2F;pdFALSE</li>
</ul>
</li>
</ul>
<h3 id="3、变量名"><a href="#3、变量名" class="headerlink" title="3、变量名"></a>3、变量名</h3><img src="C:\Users\WangTao\AppData\Roaming\Typora\typora-user-images\image-20240913132816742.png" alt="image-20240913132816742" style="zoom: 67%;" />

<h3 id="4、函数名"><a href="#4、函数名" class="headerlink" title="4、函数名"></a>4、函数名</h3><img src="C:\Users\WangTao\AppData\Roaming\Typora\typora-user-images\image-20240913132943307.png" alt="image-20240913132943307" style="zoom:67%;" />

<h1 id="二、内存管理"><a href="#二、内存管理" class="headerlink" title="二、内存管理"></a>二、内存管理</h1><h3 id="1、堆和栈"><a href="#1、堆和栈" class="headerlink" title="1、堆和栈"></a>1、堆和栈</h3><ul>
<li>堆，heap，就是一块空闲的内存，需要提供管理函数<ul>
<li>malloc：从堆里划出一块空间给程序使用</li>
<li>free：用完后，再把它标记为”空闲”的，可以再次使用</li>
</ul>
</li>
<li>栈，stack，函数调用时局部变量保存在栈中，当前程序的环境也是保存在栈中<ul>
<li>可以从堆中分配一块空间用作栈</li>
</ul>
</li>
</ul>
<img src="C:\Users\WangTao\AppData\Roaming\Typora\typora-user-images\image-20240913133522988.png" alt="image-20240913133522988" style="zoom:50%;" />

<h3 id="2、Heap相关的函数"><a href="#2、Heap相关的函数" class="headerlink" title="2、Heap相关的函数"></a>2、Heap相关的函数</h3><p><strong>pvPortMalloc&#x2F;vPortFree</strong></p>
<p>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> * <span class="title function_">pvPortMalloc</span><span class="params">( <span class="type">size_t</span> xWantedSize )</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">vPortFree</span><span class="params">( <span class="type">void</span> * pv )</span>;</span><br></pre></td></tr></table></figure>

<p>作用：分配内存、释放内存。</p>
<p>如果分配内存不成功，则返回值为NULL。</p>
<hr>
<p><strong>xPortGetFreeHeapSize</strong></p>
<p>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">xPortGetFreeHeapSize</span><span class="params">( <span class="type">void</span> )</span>;</span><br></pre></td></tr></table></figure>

<p>当前还有多少空闲内存，这函数可以用来优化内存的使用情况。比如当所有内核对象都分配好后，执行此函数返回2000，那么configTOTAL_HEAP_SIZE就可减小2000。</p>
<p>注意：在heap_3中无法使用。</p>
<hr>
<p><strong>xPortGetMinimumEverFreeHeapSize</strong></p>
<p>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">xPortGetMinimumEverFreeHeapSize</span><span class="params">( <span class="type">void</span> )</span>;</span><br></pre></td></tr></table></figure>

<p>返回：程序运行过程中，空闲内存容量的最小值。</p>
<p>注意：只有heap_4、heap_5支持此函数</p>
<h1 id="三、任务管理"><a href="#三、任务管理" class="headerlink" title="三、任务管理"></a>三、任务管理</h1><h3 id="1、创建任务"><a href="#1、创建任务" class="headerlink" title="1、创建任务"></a>1、创建任务</h3><h4 id="1-1、示例："><a href="#1-1、示例：" class="headerlink" title="1.1、示例："></a>1.1、示例：</h4><p><strong>动态分配：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建句柄</span></span><br><span class="line">TaskHandle_t xSoundTaskHandle;</span><br><span class="line"><span class="comment">//接收返回值类型,应该没用到</span></span><br><span class="line">BaseType_t ret;</span><br><span class="line"><span class="comment">//创建任务函数</span></span><br><span class="line">ret = xTaskCreate(PlayMusic, <span class="string">&quot;SoundTask&quot;</span>, <span class="number">128</span>, <span class="literal">NULL</span>, osPriorityNormal, &amp;xSoundTaskHandle);</span><br></pre></td></tr></table></figure>

<p><strong>静态分配：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> StackType_t g_pucStackOfLEDTask[<span class="number">128</span>]; <span class="comment">//因为StackType_t的类型是32位，所以不需要*4</span></span><br><span class="line"><span class="type">static</span> StaticTask_t g_TCBofLEDTask;</span><br><span class="line"><span class="type">static</span> TaskHandle_t xLEDTaskHandle;</span><br><span class="line"><span class="comment">//创建任务函数</span></span><br><span class="line">xLEDTaskHandle = xTaskCreateStatic(led_test, <span class="string">&quot;LEDTask&quot;</span>, <span class="number">128</span>, <span class="literal">NULL</span>, osPriorityNormal, g_pucStackOfLEDTask, &amp;g_TCBofLEDTask);</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-2、函数解析"><a href="#1-2、函数解析" class="headerlink" title="1.2、函数解析"></a>1.2、函数解析</h4><p>创建任务时使用的函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskCreate</span><span class="params">( TaskFunction_t pxTaskCode, <span class="comment">// 函数指针, 任务函数</span></span></span><br><span class="line"><span class="params">                        <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName, <span class="comment">// 任务的名字</span></span></span><br><span class="line"><span class="params">                        <span class="type">const</span> configSTACK_DEPTH_TYPE usStackDepth, <span class="comment">// 栈大小,单位为word,10表示40字节</span></span></span><br><span class="line"><span class="params">                        <span class="type">void</span> * <span class="type">const</span> pvParameters, <span class="comment">// 调用任务函数时传入的参数</span></span></span><br><span class="line"><span class="params">                        UBaseType_t uxPriority,    <span class="comment">// 优先级</span></span></span><br><span class="line"><span class="params">                        TaskHandle_t * <span class="type">const</span> pxCreatedTask )</span>; <span class="comment">// 任务句柄, 以后使用它来操作这个任务</span></span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>pvTaskCode</td>
<td>函数指针，任务对应的 C 函数。任务应该永远不退出，或者在退出时调用 “vTaskDelete(NULL)”。</td>
</tr>
<tr>
<td>pcName</td>
<td>任务的名称，仅用于调试目的，FreeRTOS 内部不使用。pcName 的长度为 configMAX_TASK_NAME_LEN。</td>
</tr>
<tr>
<td>usStackDepth</td>
<td>每个任务都有自己的栈，usStackDepth 指定了栈的大小，单位为 word。例如，如果传入 100，表示栈的大小为 100 word，即 400 字节。最大值为 uint16_t 的最大值。确定栈的大小并不容易，通常是根据估计来设定。精确的办法是查看反汇编代码。</td>
</tr>
<tr>
<td>pvParameters</td>
<td>调用 pvTaskCode 函数指针时使用的参数：pvTaskCode(pvParameters)。</td>
</tr>
<tr>
<td>uxPriority</td>
<td>任务的优先级范围为 0~(configMAX_PRIORITIES – 1)。数值越小，优先级越低。如果传入的值过大，xTaskCreate 会将其调整为 (configMAX_PRIORITIES – 1)。</td>
</tr>
<tr>
<td>pxCreatedTask</td>
<td>用于保存 xTaskCreate 的输出结果，即任务的句柄（task handle）。如果以后需要对该任务进行操作，如修改优先级，则需要使用此句柄。如果不需要使用该句柄，可以传入 NULL。</td>
</tr>
<tr>
<td>返回值</td>
<td>成功时返回 pdPASS，失败时返回 errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY（失败原因是内存不足）。请注意，文档中提到的失败返回值是 pdFAIL 是不正确的。pdFAIL 的值为 0，而 errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY 的值为 -1。</td>
</tr>
</tbody></table>
<p>使用静态分配内存的函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TaskHandle_t <span class="title function_">xTaskCreateStatic</span> <span class="params">( </span></span><br><span class="line"><span class="params">    TaskFunction_t pxTaskCode,   <span class="comment">// 函数指针, 任务函数</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName,   <span class="comment">// 任务的名字</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">uint32_t</span> ulStackDepth, <span class="comment">// 栈大小,单位为word,10表示40字节</span></span></span><br><span class="line"><span class="params">    <span class="type">void</span> * <span class="type">const</span> pvParameters,   <span class="comment">// 调用任务函数时传入的参数</span></span></span><br><span class="line"><span class="params">    UBaseType_t uxPriority,      <span class="comment">// 优先级</span></span></span><br><span class="line"><span class="params">    StackType_t * <span class="type">const</span> puxStackBuffer, <span class="comment">// 静态分配的栈，就是一个buffer</span></span></span><br><span class="line"><span class="params">    StaticTask_t * <span class="type">const</span> pxTaskBuffer <span class="comment">// 静态分配的任务结构体的指针，用它来操作这个任务</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>相比于使用动态分配内存创建任务的函数，最后2个参数不一样：</p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>pvTaskCode</td>
<td>函数指针，可以简单地认为任务就是一个C函数。 它稍微特殊一点：永远不退出，或者退出时要调用”vTaskDelete(NULL)”</td>
</tr>
<tr>
<td>pcName</td>
<td>任务的名字，FreeRTOS内部不使用它，仅仅起调试作用。 长度为：configMAX_TASK_NAME_LEN</td>
</tr>
<tr>
<td>usStackDepth</td>
<td>每个任务都有自己的栈，这里指定栈大小。 单位是word，比如传入100，表示栈大小为100 word，也就是400字节。 最大值为uint16_t的最大值。 怎么确定栈的大小，并不容易，很多时候是估计。 精确的办法是看反汇编码。</td>
</tr>
<tr>
<td>pvParameters</td>
<td>调用pvTaskCode函数指针时用到：pvTaskCode(pvParameters)</td>
</tr>
<tr>
<td>uxPriority</td>
<td>优先级范围：0~(configMAX_PRIORITIES – 1) 数值越小优先级越低， 如果传入过大的值，xTaskCreate会把它调整为(configMAX_PRIORITIES – 1)</td>
</tr>
<tr>
<td>puxStackBuffer</td>
<td>静态分配的栈内存，比如可以传入一个数组， 它的大小是usStackDepth*4。</td>
</tr>
<tr>
<td>pxTaskBuffer</td>
<td>静态分配的StaticTask_t结构体的指针</td>
</tr>
<tr>
<td>返回值</td>
<td>成功：返回任务句柄； 失败：NULL</td>
</tr>
</tbody></table>
<h4 id="1-3、使用任务参数"><a href="#1-3、使用任务参数" class="headerlink" title="1.3、使用任务参数"></a>1.3、使用任务参数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* 使用同一个函数创建不同的任务 */</span><br><span class="line">  xTaskCreate(LcdPrintTask, <span class="string">&quot;task1&quot;</span>, <span class="number">128</span>, &amp;g_Task1Info, osPriorityNormal, <span class="literal">NULL</span>);</span><br><span class="line">  xTaskCreate(LcdPrintTask, <span class="string">&quot;task2&quot;</span>, <span class="number">128</span>, &amp;g_Task2Info, osPriorityNormal, <span class="literal">NULL</span>);</span><br><span class="line">  xTaskCreate(LcdPrintTask, <span class="string">&quot;task3&quot;</span>, <span class="number">128</span>, &amp;g_Task3Info, osPriorityNormal, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<h3 id="2、任务的删除"><a href="#2、任务的删除" class="headerlink" title="2、任务的删除"></a>2、任务的删除</h3><h4 id="2-1、示例："><a href="#2-1、示例：" class="headerlink" title="2.1、示例："></a>2.1、示例：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除任务，传入句柄</span></span><br><span class="line">vTaskDelete(xSoundTaskHandle);</span><br></pre></td></tr></table></figure>

<h4 id="2-2、函数解析："><a href="#2-2、函数解析：" class="headerlink" title="2.2、函数解析："></a>2.2、函数解析：</h4><p>删除任务时使用的函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelete</span><span class="params">( TaskHandle_t xTaskToDelete )</span>;</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>pvTaskCode</td>
<td>任务句柄，使用xTaskCreate创建任务时可以得到一个句柄。 也可传入NULL，这表示删除自己。</td>
</tr>
</tbody></table>
<p>怎么删除任务？举个不好的例子：</p>
<ul>
<li>自杀：vTaskDelete(NULL)</li>
<li>被杀：别的任务执行vTaskDelete(pvTaskCode)，pvTaskCode是自己的句柄</li>
<li>杀人：执行vTaskDelete(pvTaskCode)，pvTaskCode是别的任务的句柄</li>
</ul>
<h3 id="3、优先级和Tick"><a href="#3、优先级和Tick" class="headerlink" title="3、优先级和Tick"></a>3、优先级和Tick</h3><ul>
<li>FreeRTOS会确保最高优先级的、可运行的任务，马上就能执行</li>
<li>对于相同优先级的、可运行的任务，轮流执行</li>
<li>FreeRTOS中也有心跳，它使用定时器产生固定间隔的中断。这叫Tick、滴答，比如每10ms发生一次时钟中断。</li>
</ul>
<h4 id="3-1、优先级实验"><a href="#3-1、优先级实验" class="headerlink" title="3.1、优先级实验"></a>3.1、优先级实验</h4><p>提高音乐播放任务的优先级，使用vTaskDelay进行延时。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改优先级，+1</span></span><br><span class="line">ret = xTaskCreate(PlayMusic, <span class="string">&quot;SoundTask&quot;</span>, <span class="number">128</span>, <span class="literal">NULL</span>, osPriorityNormal+<span class="number">1</span>, &amp;xSoundTaskHandle);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在music.h里面，要修改HAL_Delay，不然会一直执行优先级高的任务，而其他的任务不执行，造成阻塞</span></span><br><span class="line">vTaskDelay(MusicSpeed/Music_Lone_Brave[i][<span class="number">2</span>]);  <span class="comment">//vTaskDelay主动放弃cpu资源，并延时。而HAL_Delay不会主动</span></span><br></pre></td></tr></table></figure>

<h4 id="3-2、修改优先级"><a href="#3-2、修改优先级" class="headerlink" title="3.2、修改优先级"></a>3.2、修改优先级</h4><p>使用uxTaskPriorityGet来获得任务的优先级：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UBaseType_t <span class="title function_">uxTaskPriorityGet</span><span class="params">( <span class="type">const</span> TaskHandle_t xTask )</span>;</span><br></pre></td></tr></table></figure>

<p>使用参数xTask来指定任务，设置为NULL表示获取自己的优先级。</p>
<p>使用vTaskPrioritySet 来设置任务的优先级：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskPrioritySet</span><span class="params">( TaskHandle_t xTask,</span></span><br><span class="line"><span class="params">                       UBaseType_t uxNewPriority )</span>;</span><br></pre></td></tr></table></figure>

<p>使用参数xTask来指定任务，设置为NULL表示获取自己的优先级。</p>
<p>使用vTaskPrioritySet 来设置任务的优先级：</p>
<h3 id="4、任务状态"><a href="#4、任务状态" class="headerlink" title="4、任务状态"></a>4、任务状态</h3><ul>
<li>运行(Runing)</li>
<li>阻塞状态(Blocked)</li>
<li>暂停状态(Suspended)</li>
<li>就绪状态(Ready)</li>
</ul>
<img src="C:\Users\WangTao\AppData\Roaming\Typora\typora-user-images\image-20240913142618916.png" alt="image-20240913142618916" style="zoom: 67%;" />

<p>链表任务调度流程：</p>
<p><img src="C:\Users\WangTao\AppData\Roaming\Typora\typora-user-images\image-20240913143620614.png" alt="image-20240913143620614"></p>
<h3 id="5、任务暂停与恢复"><a href="#5、任务暂停与恢复" class="headerlink" title="5、任务暂停与恢复"></a>5、任务暂停与恢复</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//任务暂停：</span></span><br><span class="line">vTaskSuspend(xSoundTaskHandle);</span><br><span class="line"><span class="comment">//任务恢复：</span></span><br><span class="line">vTaskResume(xSoundTaskHandle);</span><br></pre></td></tr></table></figure>

<h3 id="6、两个delay函数"><a href="#6、两个delay函数" class="headerlink" title="6、两个delay函数"></a>6、两个delay函数</h3><ul>
<li>vTaskDelay：至少等待指定个数的Tick Interrupt才能变为就绪状态</li>
<li>vTaskDelayUntil：等待到指定的绝对时刻，才能变为就绪态；可以让任务周期性运行。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//延时500ms</span></span><br><span class="line">vTaskDelay(<span class="number">500</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取当前时刻</span></span><br><span class="line">BaseType_t preTime;</span><br><span class="line">preTime = xTaskGetTickCount();</span><br><span class="line"><span class="comment">//延时的时间为：preTime+500</span></span><br><span class="line">vTaskDelayUntil(&amp;preTime, <span class="number">500</span>);</span><br></pre></td></tr></table></figure>

<h1 id="四、同步与互斥"><a href="#四、同步与互斥" class="headerlink" title="四、同步与互斥"></a>四、同步与互斥</h1><h3 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h3><p>**同步：**哎哎哎，我正在用厕所，你等会。</p>
<p>**互斥：**哎哎哎，我正在用厕所，你不能进来。</p>
<p>**用“同步”来实现“互斥”：**我“等”你用完厕所，我再用厕所。</p>
<hr>
<p>假设有A、B两人早起抢厕所，A先行一步占用了；B慢了一步，于是就眯一会；当A用完后叫醒B，B也就愉快地上厕所了。</p>
<p>在这个过程中，A、B是互斥地访问“厕所”，“厕所”被称之为临界资源。我们使用了“休眠-唤醒”的同步机制实现了“临界资源”的“互斥访问”。</p>
<p>同一时间只能有一个人使用的资源，被称为临界资源。比如任务A、B都要使用串口来打印，串口就是临界资源。如果A、B同时使用串口，那么打印出来的信息就是A、B混杂，无法分辨。所以使用串口时，应该是这样：A用完，B再用；B用完，A再用。</p>
<h3 id="2、两个有缺陷的方法："><a href="#2、两个有缺陷的方法：" class="headerlink" title="2、两个有缺陷的方法："></a>2、<strong>两个有缺陷的方法：</strong></h3><p>1、使用标志位来进行判断任务A是否已经执行完毕，但是无法阻止任务B在判断的时候被切换出去，这时两个任务都满足条件，同时使用同一临界资源。</p>
<p>2、使用关中断，影响系统效率，影响其他进程运行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> bCanUse = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//关中断</span></span><br><span class="line">disable_irq();</span><br><span class="line">bCanUse--;</span><br><span class="line"><span class="comment">//执行完开中断</span></span><br><span class="line">enable_irq();</span><br></pre></td></tr></table></figure>

<h3 id="3、FreeRTOS提供的方法"><a href="#3、FreeRTOS提供的方法" class="headerlink" title="3、FreeRTOS提供的方法"></a>3、FreeRTOS提供的方法</h3><h1 id="五、-队列函数"><a href="#五、-队列函数" class="headerlink" title="五、 队列函数"></a>五、 队列函数</h1><p>使用队列的流程：创建队列、写队列、读队列、删除队列。</p>
<h3 id="1、创建"><a href="#1、创建" class="headerlink" title="1、创建"></a>1、创建</h3><p>队列的创建有两种方法：动态分配内存、静态分配内存，</p>
<ul>
<li>动态分配内存：xQueueCreate，队列的内存在函数内部动态分配</li>
</ul>
<p>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QueueHandle_t <span class="title function_">xQueueCreate</span><span class="params">( UBaseType_t uxQueueLength, UBaseType_t uxItemSize )</span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>uxQueueLength</td>
<td>队列长度，最多能存放多少个数据(item)</td>
</tr>
<tr>
<td>uxItemSize</td>
<td>每个数据(item)的大小：以字节为单位</td>
</tr>
<tr>
<td>返回值</td>
<td>非0：成功，返回句柄，以后使用句柄来操作队列 NULL：失败，因为内存不足</td>
</tr>
</tbody></table>
<ul>
<li>静态分配内存：xQueueCreateStatic，队列的内存要事先分配好</li>
</ul>
<p>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QueueHandle_t <span class="title function_">xQueueCreateStatic</span><span class="params">(*</span></span><br><span class="line"><span class="params">              		UBaseType_t uxQueueLength,*</span></span><br><span class="line"><span class="params">              		UBaseType_t uxItemSize,*</span></span><br><span class="line"><span class="params">              		<span class="type">uint8_t</span> *pucQueueStorageBuffer,*</span></span><br><span class="line"><span class="params">              		StaticQueue_t *pxQueueBuffer*</span></span><br><span class="line"><span class="params">           		 )</span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>uxQueueLength</td>
<td>队列长度，最多能存放多少个数据(item)</td>
</tr>
<tr>
<td>uxItemSize</td>
<td>每个数据(item)的大小：以字节为单位</td>
</tr>
<tr>
<td>pucQueueStorageBuffer</td>
<td>如果uxItemSize非0，pucQueueStorageBuffer必须指向一个uint8_t数组， 此数组大小至少为”uxQueueLength * uxItemSize”</td>
</tr>
<tr>
<td>pxQueueBuffer</td>
<td>必须执行一个StaticQueue_t结构体，用来保存队列的数据结构</td>
</tr>
<tr>
<td>返回值</td>
<td>非0：成功，返回句柄，以后使用句柄来操作队列 NULL：失败，因为pxQueueBuffer为NULL</td>
</tr>
</tbody></table>
<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例代码</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> QUEUE_LENGTH 10</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> ITEM_SIZE sizeof( uint32_t )</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">// xQueueBuffer用来保存队列结构体</span></span><br><span class="line"> StaticQueue_t xQueueBuffer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ucQueueStorage 用来保存队列的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 大小为：队列长度 * 数据大小</span></span><br><span class="line"> <span class="type">uint8_t</span> ucQueueStorage[ QUEUE_LENGTH * ITEM_SIZE ];</span><br><span class="line"></span><br><span class="line"> <span class="type">void</span> <span class="title function_">vATask</span><span class="params">( <span class="type">void</span> *pvParameters )</span></span><br><span class="line"> &#123;</span><br><span class="line">	QueueHandle_t xQueue1;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建队列: 可以容纳QUEUE_LENGTH个数据，每个数据大小是ITEM_SIZE</span></span><br><span class="line">	xQueue1 = xQueueCreateStatic( QUEUE_LENGTH,</span><br><span class="line">							ITEM_SIZE,</span><br><span class="line">                            ucQueueStorage,</span><br><span class="line">                            &amp;xQueueBuffer ); </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、复位"><a href="#2、复位" class="headerlink" title="2、复位"></a>2、复位</h3><p>队列刚被创建时，里面没有数据；使用过程中可以调用 <strong>xQueueReset()</strong> 把队列恢复为初始状态，此函数原型为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  pxQueue : 复位哪个队列;</span></span><br><span class="line"><span class="comment"> * 返回值: pdPASS(必定成功)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">BaseType_t <span class="title function_">xQueueReset</span><span class="params">( QueueHandle_t pxQueue)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="3、删除"><a href="#3、删除" class="headerlink" title="3、删除"></a>3、删除</h3><p>删除队列的函数为 <strong>vQueueDelete()</strong> ，只能删除使用动态方法创建的队列，它会释放内存。原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vQueueDelete</span><span class="params">( QueueHandle_t xQueue )</span>;</span><br></pre></td></tr></table></figure>

<h3 id="4、写队列"><a href="#4、写队列" class="headerlink" title="4、写队列"></a>4、写队列</h3><p>可以把数据写到队列头部，也可以写到尾部，这些函数有两个版本：在任务中使用、在ISR中使用。函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 等同于xQueueSendToBack</span></span><br><span class="line"><span class="comment"> * 往队列尾部写入数据，如果没有空间，阻塞时间为xTicksToWait</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xQueueSend</span><span class="params">(</span></span><br><span class="line"><span class="params">                                QueueHandle_t    xQueue,</span></span><br><span class="line"><span class="params">                                <span class="type">const</span> <span class="type">void</span>       *pvItemToQueue,</span></span><br><span class="line"><span class="params">                                TickType_t       xTicksToWait</span></span><br><span class="line"><span class="params">                            )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 往队列尾部写入数据，如果没有空间，阻塞时间为xTicksToWait</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xQueueSendToBack</span><span class="params">(</span></span><br><span class="line"><span class="params">                                QueueHandle_t    xQueue,</span></span><br><span class="line"><span class="params">                                <span class="type">const</span> <span class="type">void</span>       *pvItemToQueue,</span></span><br><span class="line"><span class="params">                                TickType_t       xTicksToWait</span></span><br><span class="line"><span class="params">                            )</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 往队列尾部写入数据，此函数可以在中断函数中使用，不可阻塞</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xQueueSendToBackFromISR</span><span class="params">(</span></span><br><span class="line"><span class="params">                                      QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                                      <span class="type">const</span> <span class="type">void</span> *pvItemToQueue,</span></span><br><span class="line"><span class="params">                                      BaseType_t *pxHigherPriorityTaskWoken</span></span><br><span class="line"><span class="params">                                   )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 往队列头部写入数据，如果没有空间，阻塞时间为xTicksToWait</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xQueueSendToFront</span><span class="params">(</span></span><br><span class="line"><span class="params">                                QueueHandle_t    xQueue,</span></span><br><span class="line"><span class="params">                                <span class="type">const</span> <span class="type">void</span>       *pvItemToQueue,</span></span><br><span class="line"><span class="params">                                TickType_t       xTicksToWait</span></span><br><span class="line"><span class="params">                            )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 往队列头部写入数据，此函数可以在中断函数中使用，不可阻塞</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xQueueSendToFrontFromISR</span><span class="params">(</span></span><br><span class="line"><span class="params">                                      QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                                      <span class="type">const</span> <span class="type">void</span> *pvItemToQueue,</span></span><br><span class="line"><span class="params">                                      BaseType_t *pxHigherPriorityTaskWoken</span></span><br><span class="line"><span class="params">                                   )</span>;</span><br></pre></td></tr></table></figure>

<p>这些函数用到的参数是类似的，统一说明如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>xQueue</td>
<td>队列句柄，要写哪个队列</td>
</tr>
<tr>
<td>pvItemToQueue</td>
<td>数据指针，这个数据的值会被复制进队列， 复制多大的数据？在创建队列时已经指定了数据大小</td>
</tr>
<tr>
<td>xTicksToWait</td>
<td>如果队列满则无法写入新数据，可以让任务进入阻塞状态， xTicksToWait表示阻塞的最大时间(Tick Count)。 如果被设为0，无法写入数据时函数会立刻返回； 如果被设为portMAX_DELAY，则会一直阻塞直到有空间可写</td>
</tr>
<tr>
<td>返回值</td>
<td>pdPASS：数据成功写入了队列 errQUEUE_FULL：写入失败，因为队列满了。</td>
</tr>
</tbody></table>
<h3 id="5、读队列"><a href="#5、读队列" class="headerlink" title="5、读队列"></a>5、读队列</h3><p>使用 <strong>xQueueReceive()</strong> 函数读队列，读到一个数据后，队列中该数据会被移除。这个函数有两个版本：在任务中使用、在ISR中使用。函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xQueueReceive</span><span class="params">( QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                          <span class="type">void</span> * <span class="type">const</span> pvBuffer,</span></span><br><span class="line"><span class="params">                          TickType_t xTicksToWait )</span>;</span><br><span class="line"></span><br><span class="line">BaseType_t <span class="title function_">xQueueReceiveFromISR</span><span class="params">(</span></span><br><span class="line"><span class="params">                                    QueueHandle_t    xQueue,</span></span><br><span class="line"><span class="params">                                    <span class="type">void</span>             *pvBuffer,</span></span><br><span class="line"><span class="params">                                    BaseType_t       *pxTaskWoken</span></span><br><span class="line"><span class="params">                                )</span>;</span><br></pre></td></tr></table></figure>

<p>参数说明如下：</p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>xQueue</td>
<td>队列句柄，要读哪个队列</td>
</tr>
<tr>
<td>pvBuffer</td>
<td>bufer指针，队列的数据会被复制到这个buffer 复制多大的数据？在创建队列时已经指定了数据大小</td>
</tr>
<tr>
<td>xTicksToWait</td>
<td>果队列空则无法读出数据，可以让任务进入阻塞状态， xTicksToWait表示阻塞的最大时间(Tick Count)。 如果被设为0，无法读出数据时函数会立刻返回； 如果被设为portMAX_DELAY，则会一直阻塞直到有数据可写</td>
</tr>
<tr>
<td>返回值</td>
<td>pdPASS：从队列读出数据入 errQUEUE_EMPTY：读取失败，因为队列空了。</td>
</tr>
</tbody></table>
<h3 id="6、查询"><a href="#6、查询" class="headerlink" title="6、查询"></a>6、查询</h3><p>可以查询队列中有多少个数据、有多少空余空间。函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 返回队列中可用数据的个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">UBaseType_t <span class="title function_">uxQueueMessagesWaiting</span><span class="params">( <span class="type">const</span> QueueHandle_t xQueue )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 返回队列中可用空间的个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">UBaseType_t <span class="title function_">uxQueueSpacesAvailable</span><span class="params">( <span class="type">const</span> QueueHandle_t xQueue )</span>;</span><br></pre></td></tr></table></figure>

<h3 id="7、覆盖-偷看"><a href="#7、覆盖-偷看" class="headerlink" title="7、覆盖&#x2F;偷看"></a>7、覆盖&#x2F;偷看</h3><p>当队列长度为1时，可以使用 <strong>xQueueOverwrite()</strong> 或 <strong>xQueueOverwriteFromISR()</strong> 来覆盖数据。</p>
<p>注意，队列长度必须为1。当队列满时，这些函数会覆盖里面的数据，这也以为着这些函数不会被阻塞。</p>
<p>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 覆盖队列</span></span><br><span class="line"><span class="comment"> * xQueue: 写哪个队列</span></span><br><span class="line"><span class="comment"> * pvItemToQueue: 数据地址</span></span><br><span class="line"><span class="comment"> * 返回值: pdTRUE表示成功, pdFALSE表示失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xQueueOverwrite</span><span class="params">(</span></span><br><span class="line"><span class="params">                           QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                           <span class="type">const</span> <span class="type">void</span> * pvItemToQueue</span></span><br><span class="line"><span class="params">                      )</span>;</span><br><span class="line"></span><br><span class="line">BaseType_t <span class="title function_">xQueueOverwriteFromISR</span><span class="params">(</span></span><br><span class="line"><span class="params">                           QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                           <span class="type">const</span> <span class="type">void</span> * pvItemToQueue,</span></span><br><span class="line"><span class="params">                           BaseType_t *pxHigherPriorityTaskWoken</span></span><br><span class="line"><span class="params">                      )</span>;</span><br></pre></td></tr></table></figure>

<p>如果想让队列中的数据供多方读取，也就是说读取时不要移除数据，要留给后来人。那么可以使用”窥视”，也就是**xQueuePeek()**或**xQueuePeekFromISR()**。这些函数会从队列中复制出数据，但是不移除数据。这也意味着，如果队列中没有数据，那么”偷看”时会导致阻塞；一旦队列中有数据，以后每次”偷看”都会成功。</p>
<p>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 偷看队列</span></span><br><span class="line"><span class="comment"> * xQueue: 偷看哪个队列</span></span><br><span class="line"><span class="comment"> * pvItemToQueue: 数据地址, 用来保存复制出来的数据</span></span><br><span class="line"><span class="comment"> * xTicksToWait: 没有数据的话阻塞一会</span></span><br><span class="line"><span class="comment"> * 返回值: pdTRUE表示成功, pdFALSE表示失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xQueuePeek</span><span class="params">(</span></span><br><span class="line"><span class="params">                          QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                          <span class="type">void</span> * <span class="type">const</span> pvBuffer,</span></span><br><span class="line"><span class="params">                          TickType_t xTicksToWait</span></span><br><span class="line"><span class="params">                      )</span>;</span><br><span class="line"></span><br><span class="line">BaseType_t <span class="title function_">xQueuePeekFromISR</span><span class="params">(</span></span><br><span class="line"><span class="params">                                 QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                                 <span class="type">void</span> *pvBuffer,</span></span><br><span class="line"><span class="params">                             )</span>;</span><br></pre></td></tr></table></figure>

<h1 id="六、信号量函数"><a href="#六、信号量函数" class="headerlink" title="六、信号量函数"></a>六、信号量函数</h1><p>使用信号量时，先创建、然后去添加资源、获得资源。使用句柄来表示一个信号量。</p>
<h3 id="6-1、-创建"><a href="#6-1、-创建" class="headerlink" title="6.1、 创建"></a>6.1、 创建</h3><p>使用信号量之前，要先创建，得到一个句柄；使用信号量时，要使用句柄来表明使用哪个信号量。 对于二进制信号量、计数型信号量，它们的创建函数不一样：</p>
<table>
<thead>
<tr>
<th></th>
<th>二进制信号量</th>
<th>计数型信号量</th>
</tr>
</thead>
<tbody><tr>
<td>动态创建</td>
<td>xSemaphoreCreateBinary 计数值初始值为0</td>
<td>xSemaphoreCreateCounting</td>
</tr>
<tr>
<td></td>
<td>vSemaphoreCreateBinary(过时了) 计数值初始值为1</td>
<td></td>
</tr>
<tr>
<td>静态创建</td>
<td>xSemaphoreCreateBinaryStatic</td>
<td>xSemaphoreCreateCountingStatic</td>
</tr>
</tbody></table>
<p>创建二进制信号量的函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建一个二进制信号量，返回它的句柄。</span></span><br><span class="line"><span class="comment"> * 此函数内部会分配信号量结构体 </span></span><br><span class="line"><span class="comment"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateBinary</span><span class="params">( <span class="type">void</span> )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建一个二进制信号量，返回它的句柄。</span></span><br><span class="line"><span class="comment"> * 此函数无需动态分配内存，所以需要先有一个StaticSemaphore_t结构体，并传入它的指针</span></span><br><span class="line"><span class="comment"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateBinaryStatic</span><span class="params">( StaticSemaphore_t *pxSemaphoreBuffer )</span>;</span><br></pre></td></tr></table></figure>

<p>创建计数型信号量的函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建一个计数型信号量，返回它的句柄。</span></span><br><span class="line"><span class="comment"> * 此函数内部会分配信号量结构体 </span></span><br><span class="line"><span class="comment"> * uxMaxCount: 最大计数值</span></span><br><span class="line"><span class="comment"> * uxInitialCount: 初始计数值</span></span><br><span class="line"><span class="comment"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateCounting</span><span class="params">(UBaseType_t uxMaxCount, UBaseType_t uxInitialCount)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建一个计数型信号量，返回它的句柄。</span></span><br><span class="line"><span class="comment"> * 此函数无需动态分配内存，所以需要先有一个StaticSemaphore_t结构体，并传入它的指针</span></span><br><span class="line"><span class="comment"> * uxMaxCount: 最大计数值</span></span><br><span class="line"><span class="comment"> * uxInitialCount: 初始计数值</span></span><br><span class="line"><span class="comment"> * pxSemaphoreBuffer: StaticSemaphore_t结构体指针</span></span><br><span class="line"><span class="comment"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateCountingStatic</span><span class="params">( UBaseType_t uxMaxCount, </span></span><br><span class="line"><span class="params">                                                 UBaseType_t uxInitialCount, </span></span><br><span class="line"><span class="params">                                                 StaticSemaphore_t *pxSemaphoreBuffer )</span>;</span><br></pre></td></tr></table></figure>

<h3 id="6-2、删除"><a href="#6-2、删除" class="headerlink" title="6.2、删除"></a>6.2、删除</h3><p>对于动态创建的信号量，不再需要它们时，可以删除它们以回收内存。</p>
<p>vSemaphoreDelete可以用来删除二进制信号量、计数型信号量，函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * xSemaphore: 信号量句柄，你要删除哪个信号量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vSemaphoreDelete</span><span class="params">( SemaphoreHandle_t xSemaphore )</span>;</span><br></pre></td></tr></table></figure>

<h3 id="6-3、give-take"><a href="#6-3、give-take" class="headerlink" title="6.3、give&#x2F;take"></a>6.3、give&#x2F;take</h3><p>二进制信号量、计数型信号量的give、take操作函数是一样的。这些函数也分为2个版本：给任务使用，给ISR使用。列表如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>在任务中使用</th>
<th>在ISR中使用</th>
</tr>
</thead>
<tbody><tr>
<td>give</td>
<td>xSemaphoreGive</td>
<td>xSemaphoreGiveFromISR</td>
</tr>
<tr>
<td>take</td>
<td>xSemaphoreTake</td>
<td>xSemaphoreTakeFromISR</td>
</tr>
</tbody></table>
<p>xSemaphoreGive的函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xSemaphoreGive</span><span class="params">( SemaphoreHandle_t xSemaphore )</span>;</span><br></pre></td></tr></table></figure>

<p>xSemaphoreGive函数的参数与返回值列表如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>xSemaphore</td>
<td>信号量句柄，释放哪个信号量</td>
</tr>
<tr>
<td>返回值</td>
<td>pdTRUE表示成功, 如果二进制信号量的计数值已经是1，再次调用此函数则返回失败； 如果计数型信号量的计数值已经是最大值，再次调用此函数则返回失败</td>
</tr>
</tbody></table>
<p>pxHigherPriorityTaskWoken的函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xSemaphoreGiveFromISR</span><span class="params">(</span></span><br><span class="line"><span class="params">                        SemaphoreHandle_t xSemaphore,</span></span><br><span class="line"><span class="params">                        BaseType_t *pxHigherPriorityTaskWoken</span></span><br><span class="line"><span class="params">                    )</span>;</span><br></pre></td></tr></table></figure>

<p>xSemaphoreGiveFromISR函数的参数与返回值列表如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>xSemaphore</td>
<td>信号量句柄，释放哪个信号量</td>
</tr>
<tr>
<td>pxHigherPriorityTaskWoken</td>
<td>如果释放信号量导致更高优先级的任务变为了就绪态， 则*pxHigherPriorityTaskWoken &#x3D; pdTRUE</td>
</tr>
<tr>
<td>返回值</td>
<td>pdTRUE表示成功, 如果二进制信号量的计数值已经是1，再次调用此函数则返回失败； 如果计数型信号量的计数值已经是最大值，再次调用此函数则返回失败</td>
</tr>
</tbody></table>
<p>xSemaphoreTake的函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xSemaphoreTake</span><span class="params">(</span></span><br><span class="line"><span class="params">                   SemaphoreHandle_t xSemaphore,</span></span><br><span class="line"><span class="params">                   TickType_t xTicksToWait</span></span><br><span class="line"><span class="params">               )</span>;</span><br></pre></td></tr></table></figure>

<p>xSemaphoreTake函数的参数与返回值列表如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>xSemaphore</td>
<td>信号量句柄，获取哪个信号量</td>
</tr>
<tr>
<td>xTicksToWait</td>
<td>如果无法马上获得信号量，阻塞一会： 0：不阻塞，马上返回 portMAX_DELAY: 一直阻塞直到成功 其他值: 阻塞的Tick个数，可以使用*pdMS_TO_TICKS()*来指定阻塞时间为若干ms</td>
</tr>
<tr>
<td>返回值</td>
<td>pdTRUE表示成功</td>
</tr>
</tbody></table>
<p>xSemaphoreTakeFromISR的函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xSemaphoreTakeFromISR</span><span class="params">(</span></span><br><span class="line"><span class="params">                        SemaphoreHandle_t xSemaphore,</span></span><br><span class="line"><span class="params">                        BaseType_t *pxHigherPriorityTaskWoken</span></span><br><span class="line"><span class="params">                    )</span>;</span><br></pre></td></tr></table></figure>

<p>xSemaphoreTakeFromISR函数的参数与返回值列表如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>xSemaphore</td>
<td>信号量句柄，获取哪个信号量</td>
</tr>
<tr>
<td>pxHigherPriorityTaskWoken</td>
<td>如果获取信号量导致更高优先级的任务变为了就绪态， 则*pxHigherPriorityTaskWoken &#x3D; pdTRUE</td>
</tr>
<tr>
<td>返回值</td>
<td>pdTRUE表示成功</td>
</tr>
</tbody></table>
<h1 id="七、互斥量函数"><a href="#七、互斥量函数" class="headerlink" title="七、互斥量函数"></a>七、互斥量函数</h1><h3 id="7-1、创建"><a href="#7-1、创建" class="headerlink" title="7.1、创建"></a>7.1、创建</h3><p>互斥量是一种特殊的二进制信号量。</p>
<p>使用互斥量时，先创建、然后去获得、释放它。使用句柄来表示一个互斥量。</p>
<p>创建互斥量的函数有2种：动态分配内存，静态分配内存，函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建一个互斥量，返回它的句柄。</span></span><br><span class="line"><span class="comment"> * 此函数内部会分配互斥量结构体 </span></span><br><span class="line"><span class="comment"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateMutex</span><span class="params">( <span class="type">void</span> )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建一个互斥量，返回它的句柄。</span></span><br><span class="line"><span class="comment"> * 此函数无需动态分配内存，所以需要先有一个StaticSemaphore_t结构体，并传入它的指针</span></span><br><span class="line"><span class="comment"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateMutexStatic</span><span class="params">( StaticSemaphore_t *pxMutexBuffer )</span>;</span><br></pre></td></tr></table></figure>

<p>要想使用互斥量，需要在配置文件FreeRTOSConfig.h中定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_MUTEXES 1</span></span><br></pre></td></tr></table></figure>

<h3 id="7-2、其他函数"><a href="#7-2、其他函数" class="headerlink" title="7.2、其他函数"></a>7.2、其他函数</h3><p>要注意的是，互斥量不能在ISR中使用。</p>
<p>各类操作函数，比如删除、give&#x2F;take，跟一般是信号量是一样的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * xSemaphore: 信号量句柄，你要删除哪个信号量, 互斥量也是一种信号量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vSemaphoreDelete</span><span class="params">( SemaphoreHandle_t xSemaphore )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 释放 */</span></span><br><span class="line">BaseType_t <span class="title function_">xSemaphoreGive</span><span class="params">( SemaphoreHandle_t xSemaphore )</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获得 */</span></span><br><span class="line">BaseType_t <span class="title function_">xSemaphoreTake</span><span class="params">(</span></span><br><span class="line"><span class="params">                   SemaphoreHandle_t xSemaphore,</span></span><br><span class="line"><span class="params">                   TickType_t xTicksToWait</span></span><br><span class="line"><span class="params">               )</span>;</span><br></pre></td></tr></table></figure>

<h1 id="八、事件组函数"><a href="#八、事件组函数" class="headerlink" title="八、事件组函数"></a>八、事件组函数</h1><h3 id="8-1、创建"><a href="#8-1、创建" class="headerlink" title="8.1、创建"></a>8.1、创建</h3><p>使用事件组之前，要先创建，得到一个句柄；使用事件组时，要使用句柄来表明使用哪个事件组。</p>
<p>有两种创建方法：动态分配内存、静态分配内存。函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建一个事件组，返回它的句柄。</span></span><br><span class="line"><span class="comment"> * 此函数内部会分配事件组结构体 </span></span><br><span class="line"><span class="comment"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">EventGroupHandle_t <span class="title function_">xEventGroupCreate</span><span class="params">( <span class="type">void</span> )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建一个事件组，返回它的句柄。</span></span><br><span class="line"><span class="comment"> * 此函数无需动态分配内存，所以需要先有一个StaticEventGroup_t结构体，并传入它的指针</span></span><br><span class="line"><span class="comment"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">EventGroupHandle_t <span class="title function_">xEventGroupCreateStatic</span><span class="params">( StaticEventGroup_t * pxEventGroupBuffer )</span>;</span><br></pre></td></tr></table></figure>

<h3 id="8-2、删除"><a href="#8-2、删除" class="headerlink" title="8.2、删除"></a>8.2、删除</h3><p>对于动态创建的事件组，不再需要它们时，可以删除它们以回收内存。</p>
<p><strong>vEventGroupDelete</strong>可以用来删除事件组，函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * xEventGroup: 事件组句柄，你要删除哪个事件组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vEventGroupDelete</span><span class="params">( EventGroupHandle_t xEventGroup )</span></span><br></pre></td></tr></table></figure>

<h3 id="8-3、设置事件"><a href="#8-3、设置事件" class="headerlink" title="8.3、设置事件"></a>8.3、设置事件</h3><p>可以设置事件组的某个位、某些位，使用的函数有2个：</p>
<ul>
<li>在任务中使用<strong>xEventGroupSetBits()</strong></li>
<li>在ISR中使用<strong>xEventGroupSetBitsFromISR()</strong></li>
</ul>
<p>有一个或多个任务在等待事件，如果这些事件符合这些任务的期望，那么任务还会被唤醒。</p>
<p>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 设置事件组中的位</span></span><br><span class="line"><span class="comment"> * xEventGroup: 哪个事件组</span></span><br><span class="line"><span class="comment"> * uxBitsToSet: 设置哪些位? </span></span><br><span class="line"><span class="comment"> *              如果uxBitsToSet的bitX, bitY为1, 那么事件组中的bitX, bitY被设置为1</span></span><br><span class="line"><span class="comment"> *              可以用来设置多个位，比如 0x15 就表示设置bit4, bit2, bit0</span></span><br><span class="line"><span class="comment"> * 返回值: 返回原来的事件值(没什么意义, 因为很可能已经被其他任务修改了)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">EventBits_t <span class="title function_">xEventGroupSetBits</span><span class="params">( EventGroupHandle_t xEventGroup,</span></span><br><span class="line"><span class="params">                                    <span class="type">const</span> EventBits_t uxBitsToSet )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置事件组中的位</span></span><br><span class="line"><span class="comment"> * xEventGroup: 哪个事件组</span></span><br><span class="line"><span class="comment"> * uxBitsToSet: 设置哪些位? </span></span><br><span class="line"><span class="comment"> *              如果uxBitsToSet的bitX, bitY为1, 那么事件组中的bitX, bitY被设置为1</span></span><br><span class="line"><span class="comment"> *              可以用来设置多个位，比如 0x15 就表示设置bit4, bit2, bit0</span></span><br><span class="line"><span class="comment"> * pxHigherPriorityTaskWoken: 有没有导致更高优先级的任务进入就绪态? pdTRUE-有, pdFALSE-没有</span></span><br><span class="line"><span class="comment"> * 返回值: pdPASS-成功, pdFALSE-失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xEventGroupSetBitsFromISR</span><span class="params">( EventGroupHandle_t xEventGroup,</span></span><br><span class="line"><span class="params">									  <span class="type">const</span> EventBits_t uxBitsToSet,</span></span><br><span class="line"><span class="params">									  BaseType_t * pxHigherPriorityTaskWoken )</span>;</span><br></pre></td></tr></table></figure>

<p>值得注意的是，ISR中的函数，比如队列函数<strong>xQueueSendToBackFromISR</strong>、信号量函数<strong>xSemaphoreGiveFromISR</strong>，它们会唤醒某个任务，最多只会唤醒1个任务。</p>
<p>但是设置事件组时，有可能导致多个任务被唤醒，这会带来很大的不确定性。所以<strong>xEventGroupSetBitsFromISR</strong>函数不是直接去设置事件组，而是给一个FreeRTOS后台任务(daemon task)发送队列数据，由这个任务来设置事件组。</p>
<p>如果后台任务的优先级比当前被中断的任务优先级高，<strong>xEventGroupSetBitsFromISR</strong>会设置<strong>pxHigherPriorityTaskWoken</strong>为pdTRUE。</p>
<p>如果daemon task成功地把队列数据发送给了后台任务，那么<strong>xEventGroupSetBitsFromISR</strong>的返回值就是pdPASS。</p>
<h3 id="8-4、等待事件"><a href="#8-4、等待事件" class="headerlink" title="8.4、等待事件"></a>8.4、等待事件</h3><p>使用<strong>xEventGroupWaitBits</strong>来等待事件，可以等待某一位、某些位中的任意一个，也可以等待多位；等到期望的事件后，还可以清除某些位。</p>
<p>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EventBits_t <span class="title function_">xEventGroupWaitBits</span><span class="params">( EventGroupHandle_t xEventGroup,</span></span><br><span class="line"><span class="params">                                 <span class="type">const</span> EventBits_t uxBitsToWaitFor,</span></span><br><span class="line"><span class="params">                                 <span class="type">const</span> BaseType_t xClearOnExit,</span></span><br><span class="line"><span class="params">                                 <span class="type">const</span> BaseType_t xWaitForAllBits,</span></span><br><span class="line"><span class="params">                                 TickType_t xTicksToWait )</span>;</span><br></pre></td></tr></table></figure>

<p>先引入一个概念：unblock condition。一个任务在等待事件发生时，它处于阻塞状态；当期望的时间发生时，这个状态就叫”unblock condition”，非阻塞条件，或称为”非阻塞条件成立”；当”非阻塞条件成立”后，该任务就可以变为就绪态。</p>
<p>函数参数说明列表如下：</p>
<table>
<thead>
<tr>
<th align="center"><strong>参数</strong></th>
<th align="left"><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">xEventGroup</td>
<td align="left">等待哪个事件组？</td>
</tr>
<tr>
<td align="center">uxBitsToWaitFor</td>
<td align="left">等待哪些位？哪些位要被测试？</td>
</tr>
<tr>
<td align="center">xWaitForAllBits</td>
<td align="left">怎么测试？是”AND”还是”OR”？ pdTRUE: 等待的位，全部为1; pdFALSE: 等待的位，某一个为1即可</td>
</tr>
<tr>
<td align="center">xClearOnExit</td>
<td align="left">函数提出前是否要清除事件？ pdTRUE: 清除uxBitsToWaitFor指定的位 pdFALSE: 不清除</td>
</tr>
<tr>
<td align="center">xTicksToWait</td>
<td align="left">如果期待的事件未发生，阻塞多久。 可以设置为0：判断后即刻返回； 可设置为portMAX_DELAY：一定等到成功才返回； 可以设置为期望的Tick Count，一般用*pdMS_TO_TICKS()*把ms转换为Tick Count</td>
</tr>
<tr>
<td align="center">返回值</td>
<td align="left">返回的是事件值， 如果期待的事件发生了，返回的是”非阻塞条件成立”时的事件值； 如果是超时退出，返回的是超时时刻的事件值。</td>
</tr>
</tbody></table>
<p>举例如下：</p>
<table>
<thead>
<tr>
<th align="center">事件组的值</th>
<th align="center">uxBitsToWaitFor</th>
<th align="center">xWaitForAllBits</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0100</td>
<td align="center">0101</td>
<td align="center">pdTRUE</td>
<td align="left">任务期望bit0,bit2都为1， 当前值只有bit2满足，任务进入阻塞态； 当事件组中bit0,bit2都为1时退出阻塞态</td>
</tr>
<tr>
<td align="center">0100</td>
<td align="center">0110</td>
<td align="center">pdFALSE</td>
<td align="left">任务期望bit0,bit2某一个为1， 当前值满足，所以任务成功退出</td>
</tr>
<tr>
<td align="center">0100</td>
<td align="center">0110</td>
<td align="center">pdTRUE</td>
<td align="left">任务期望bit1,bit2都为1， 当前值不满足，任务进入阻塞态； 当事件组中bit1,bit2都为1时退出阻塞态</td>
</tr>
</tbody></table>
<p>你可以使用*xEventGroupWaitBits()<em>等待期望的事件，它发生之后再使用</em>xEventGroupClearBits()*来清除。但是这两个函数之间，有可能被其他任务或中断抢占，它们可能会修改事件组。</p>
<p>可以使用设置<em>xClearOnExit</em>为pdTRUE，使得对事件组的测试、清零都在*xEventGroupWaitBits()*函数内部完成，这是一个原子操作。</p>
<h3 id="8-5、同步点"><a href="#8-5、同步点" class="headerlink" title="8.5、同步点"></a>8.5、同步点</h3><p>有一个事情需要多个任务协同，比如：</p>
<ul>
<li>任务A：炒菜</li>
<li>任务B：买酒</li>
<li>任务C：摆台</li>
<li>A、B、C做好自己的事后，还要等别人做完；大家一起做完，才可开饭</li>
</ul>
<p>使用 <strong>xEventGroupSync()</strong> 函数可以同步多个任务：</p>
<ul>
<li>可以设置某位、某些位，表示自己做了什么事</li>
<li>可以等待某位、某些位，表示要等等其他任务</li>
<li>期望的时间发生后， <strong>xEventGroupSync()</strong> 才会成功返回。</li>
<li><strong>xEventGroupSync</strong>成功返回后，会清除事件</li>
</ul>
<p><strong>xEventGroupSync</strong> 函数原型如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EventBits_t xEventGroupSync(    EventGroupHandle_t xEventGroup,</span><br><span class="line">                                const EventBits_t uxBitsToSet,</span><br><span class="line">                                const EventBits_t uxBitsToWaitFor,</span><br><span class="line">                                TickType_t xTicksToWait );</span><br></pre></td></tr></table></figure>

<p>参数列表如下：</p>
<table>
<thead>
<tr>
<th align="center"><strong>参数</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">xEventGroup</td>
<td>哪个事件组？</td>
</tr>
<tr>
<td align="center">uxBitsToSet</td>
<td>要设置哪些事件？我完成了哪些事件？ 比如0x05(二进制为0101)会导致事件组的bit0,bit2被设置为1</td>
</tr>
<tr>
<td align="center">uxBitsToWaitFor</td>
<td>等待那个位、哪些位？ 比如0x15(二级制10101)，表示要等待bit0,bit2,bit4都为1</td>
</tr>
<tr>
<td align="center">xTicksToWait</td>
<td>如果期待的事件未发生，阻塞多久。 可以设置为0：判断后即刻返回； 可设置为portMAX_DELAY：一定等到成功才返回； 可以设置为期望的Tick Count，一般用*pdMS_TO_TICKS()*把ms转换为Tick Count</td>
</tr>
<tr>
<td align="center">返回值</td>
<td>返回的是事件值， 如果期待的事件发生了，返回的是”非阻塞条件成立”时的事件值； 如果是超时退出，返回的是超时时刻的事件值。</td>
</tr>
</tbody></table>
<p>参数列表如下：</p>
<table>
<thead>
<tr>
<th align="center"><strong>参数</strong></th>
<th align="left"><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">xEventGroup</td>
<td align="left">哪个事件组？</td>
</tr>
<tr>
<td align="center">uxBitsToSet</td>
<td align="left">要设置哪些事件？我完成了哪些事件？ 比如0x05(二进制为0101)会导致事件组的bit0,bit2被设置为1</td>
</tr>
<tr>
<td align="center">uxBitsToWaitFor</td>
<td align="left">等待那个位、哪些位？ 比如0x15(二级制10101)，表示要等待bit0,bit2,bit4都为1</td>
</tr>
<tr>
<td align="center">xTicksToWait</td>
<td align="left">如果期待的事件未发生，阻塞多久。 可以设置为0：判断后即刻返回； 可设置为portMAX_DELAY：一定等到成功才返回； 可以设置为期望的Tick Count，一般用*pdMS_TO_TICKS()*把ms转换为Tick Count</td>
</tr>
<tr>
<td align="center">返回值</td>
<td align="left">返回的是事件值， 如果期待的事件发生了，返回的是”非阻塞条件成立”时的事件值； 如果是超时退出，返回的是超时时刻的事件值。</td>
</tr>
</tbody></table>
<h3 id="8-6、任务通知"><a href="#8-6、任务通知" class="headerlink" title="8.6、任务通知"></a>8.6、任务通知</h3><p>本节代码为：27_tasknotification_car_game，主要看nwatch\game2.c。</p>
<p>car1运行到终点后，给car2发送轻量级信号量，给car3发送数值。car2等待轻量级信号量，car3等待特定的通知值。</p>
<p>使用任务通知时，需要知道对方的任务句柄，创建任务时要记录任务句柄，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">40</span> <span class="type">static</span> TaskHandle_t g_TaskHandleCar2;</span><br><span class="line"></span><br><span class="line"><span class="number">41</span> <span class="type">static</span> TaskHandle_t g_TaskHandleCar3;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 省略 */</span></span><br><span class="line"></span><br><span class="line"><span class="number">315</span> xTaskCreate(Car1Task, <span class="string">&quot;car1&quot;</span>, <span class="number">128</span>, &amp;g_cars[<span class="number">0</span>], osPriorityNormal, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">316</span> xTaskCreate(Car2Task, <span class="string">&quot;car2&quot;</span>, <span class="number">128</span>, &amp;g_cars[<span class="number">1</span>], osPriorityNormal+<span class="number">2</span>, &amp;g_TaskHandleCar2);</span><br><span class="line"></span><br><span class="line"><span class="number">317</span> xTaskCreate(Car3Task, <span class="string">&quot;car3&quot;</span>, <span class="number">128</span>, &amp;g_cars[<span class="number">2</span>], osPriorityNormal+<span class="number">2</span>, &amp;g_TaskHandleCar3);	</span><br></pre></td></tr></table></figure>

<p>car2等待轻量级信号量，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">176</span>   ulTaskNotifyTake(pdTRUE, portMAX_DELAY);</span><br></pre></td></tr></table></figure>

<p>car3等待通知值为100，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">224</span>   <span class="type">uint32_t</span> val;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 省略 */</span></span><br><span class="line"></span><br><span class="line"><span class="number">241</span>   <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="number">242</span>   &#123;</span><br><span class="line"></span><br><span class="line"><span class="number">243</span>      xTaskNotifyWait(~<span class="number">0</span>, ~<span class="number">0</span>, &amp;val, portMAX_DELAY);</span><br><span class="line"></span><br><span class="line"><span class="number">244</span>  &#125; <span class="keyword">while</span> (val != <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>car1到达终点后，向car2、car3发出任务通知，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">145</span>                   <span class="comment">/* 发出任务通知给car2,car3 */</span></span><br><span class="line"></span><br><span class="line"><span class="number">146</span>                   xTaskNotifyGive(g_TaskHandleCar2);</span><br><span class="line"></span><br><span class="line"><span class="number">147</span></span><br><span class="line"></span><br><span class="line"><span class="number">148</span>                  xTaskNotify(g_TaskHandleCar3, <span class="number">100</span>, eSetValueWithOverwrite);</span><br></pre></td></tr></table></figure>

<p>实验现象：car1到达终点后，car2、car3才会启动。</p>
<h1 id="九、软件定时器的函数"><a href="#九、软件定时器的函数" class="headerlink" title="九、软件定时器的函数"></a>九、软件定时器的函数</h1><p>根据定时器的状态转换图，就可以知道所涉及的函数：</p>
<p><img src="http://photos.100ask.net/rtos-docs/FreeRTOS/DShanMCU-F103/chapter-16/image6.png" alt="img"></p>
<h3 id="9-1、创建"><a href="#9-1、创建" class="headerlink" title="9.1、创建"></a>9.1、创建</h3><p>要使用定时器，需要先创建它，得到它的句柄。</p>
<p>有两种方法创建定时器：动态分配内存、静态分配内存。函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 使用动态分配内存的方法创建定时器</span></span><br><span class="line"><span class="comment"> * pcTimerName:定时器名字, 用处不大, 尽在调试时用到</span></span><br><span class="line"><span class="comment"> * xTimerPeriodInTicks: 周期, 以Tick为单位</span></span><br><span class="line"><span class="comment"> * uxAutoReload: 类型, pdTRUE表示自动加载, pdFALSE表示一次性</span></span><br><span class="line"><span class="comment"> * pvTimerID: 回调函数可以使用此参数, 比如分辨是哪个定时器</span></span><br><span class="line"><span class="comment"> * pxCallbackFunction: 回调函数</span></span><br><span class="line"><span class="comment"> * 返回值: 成功则返回TimerHandle_t, 否则返回NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">TimerHandle_t <span class="title function_">xTimerCreate</span><span class="params">( <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcTimerName, </span></span><br><span class="line"><span class="params">							<span class="type">const</span> TickType_t xTimerPeriodInTicks,</span></span><br><span class="line"><span class="params">							<span class="type">const</span> UBaseType_t uxAutoReload,</span></span><br><span class="line"><span class="params">							<span class="type">void</span> * <span class="type">const</span> pvTimerID,</span></span><br><span class="line"><span class="params">							TimerCallbackFunction_t pxCallbackFunction )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用静态分配内存的方法创建定时器</span></span><br><span class="line"><span class="comment"> * pcTimerName:定时器名字, 用处不大, 尽在调试时用到</span></span><br><span class="line"><span class="comment"> * xTimerPeriodInTicks: 周期, 以Tick为单位</span></span><br><span class="line"><span class="comment"> * uxAutoReload: 类型, pdTRUE表示自动加载, pdFALSE表示一次性</span></span><br><span class="line"><span class="comment"> * pvTimerID: 回调函数可以使用此参数, 比如分辨是哪个定时器</span></span><br><span class="line"><span class="comment"> * pxCallbackFunction: 回调函数</span></span><br><span class="line"><span class="comment"> * pxTimerBuffer: 传入一个StaticTimer_t结构体, 将在上面构造定时器</span></span><br><span class="line"><span class="comment"> * 返回值: 成功则返回TimerHandle_t, 否则返回NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">TimerHandle_t <span class="title function_">xTimerCreateStatic</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcTimerName,</span></span><br><span class="line"><span class="params">                                 TickType_t xTimerPeriodInTicks,</span></span><br><span class="line"><span class="params">                                 UBaseType_t uxAutoReload,</span></span><br><span class="line"><span class="params">                                 <span class="type">void</span> * pvTimerID,</span></span><br><span class="line"><span class="params">                                 TimerCallbackFunction_t pxCallbackFunction,</span></span><br><span class="line"><span class="params">                                 StaticTimer_t *pxTimerBuffer )</span>;</span><br></pre></td></tr></table></figure>

<p>回调函数的类型是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ATimerCallback</span><span class="params">( TimerHandle_t xTimer )</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(* TimerCallbackFunction_t)</span><span class="params">( TimerHandle_t xTimer )</span>;</span><br></pre></td></tr></table></figure>

<h3 id="9-2、删除"><a href="#9-2、删除" class="headerlink" title="9.2、删除"></a>9.2、删除</h3><p>动态分配的定时器，不再需要时可以删除掉以回收内存。删除函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 删除定时器</span></span><br><span class="line"><span class="comment"> * xTimer: 要删除哪个定时器</span></span><br><span class="line"><span class="comment"> * xTicksToWait: 超时时间</span></span><br><span class="line"><span class="comment"> * 返回值: pdFAIL表示&quot;删除命令&quot;在xTicksToWait个Tick内无法写入队列</span></span><br><span class="line"><span class="comment"> *        pdPASS表示成功</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">BaseType_t <span class="title function_">xTimerDelete</span><span class="params">( TimerHandle_t xTimer, TickType_t xTicksToWait )</span>;</span><br></pre></td></tr></table></figure>

<p>定时器的很多API函数，都是通过发送”命令”到命令队列，由守护任务来实现。</p>
<p>如果队列满了，”命令”就无法即刻写入队列。我们可以指定一个超时时间 <strong>xTicksToWait</strong> ，等待一会。</p>
<h3 id="9-3、启动-停止"><a href="#9-3、启动-停止" class="headerlink" title="9.3、启动&#x2F;停止"></a>9.3、启动&#x2F;停止</h3><p>启动定时器就是设置它的状态为运行态(Running、Active)。</p>
<p>停止定时器就是设置它的状态为冬眠(Dormant)，让它不能运行。</p>
<p>涉及的函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 启动定时器</span></span><br><span class="line"><span class="comment"> * xTimer: 哪个定时器</span></span><br><span class="line"><span class="comment"> * xTicksToWait: 超时时间</span></span><br><span class="line"><span class="comment"> * 返回值: pdFAIL表示&quot;启动命令&quot;在xTicksToWait个Tick内无法写入队列</span></span><br><span class="line"><span class="comment"> *        pdPASS表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xTimerStart</span><span class="params">( TimerHandle_t xTimer, TickType_t xTicksToWait )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 启动定时器(ISR版本)</span></span><br><span class="line"><span class="comment"> * xTimer: 哪个定时器</span></span><br><span class="line"><span class="comment"> * pxHigherPriorityTaskWoken: 向队列发出命令使得守护任务被唤醒,</span></span><br><span class="line"><span class="comment"> *                            如果守护任务的优先级比当前任务的高,</span></span><br><span class="line"><span class="comment"> *                            则&quot;*pxHigherPriorityTaskWoken = pdTRUE&quot;,</span></span><br><span class="line"><span class="comment"> *                            表示需要进行任务调度</span></span><br><span class="line"><span class="comment"> * 返回值: pdFAIL表示&quot;启动命令&quot;无法写入队列</span></span><br><span class="line"><span class="comment"> *        pdPASS表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xTimerStartFromISR</span><span class="params">(   TimerHandle_t xTimer,</span></span><br><span class="line"><span class="params">                                 BaseType_t *pxHigherPriorityTaskWoken )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 停止定时器</span></span><br><span class="line"><span class="comment"> * xTimer: 哪个定时器</span></span><br><span class="line"><span class="comment"> * xTicksToWait: 超时时间</span></span><br><span class="line"><span class="comment"> * 返回值: pdFAIL表示&quot;停止命令&quot;在xTicksToWait个Tick内无法写入队列</span></span><br><span class="line"><span class="comment"> *        pdPASS表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xTimerStop</span><span class="params">( TimerHandle_t xTimer, TickType_t xTicksToWait )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 停止定时器(ISR版本)</span></span><br><span class="line"><span class="comment"> * xTimer: 哪个定时器</span></span><br><span class="line"><span class="comment"> * pxHigherPriorityTaskWoken: 向队列发出命令使得守护任务被唤醒,</span></span><br><span class="line"><span class="comment"> *                            如果守护任务的优先级比当前任务的高,</span></span><br><span class="line"><span class="comment"> *                            则&quot;*pxHigherPriorityTaskWoken = pdTRUE&quot;,</span></span><br><span class="line"><span class="comment"> *                            表示需要进行任务调度</span></span><br><span class="line"><span class="comment"> * 返回值: pdFAIL表示&quot;停止命令&quot;无法写入队列</span></span><br><span class="line"><span class="comment"> *        pdPASS表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xTimerStopFromISR</span><span class="params">(    TimerHandle_t xTimer,</span></span><br><span class="line"><span class="params">                                 BaseType_t *pxHigherPriorityTaskWoken )</span>;</span><br></pre></td></tr></table></figure>

<p>注意，这些函数的 <strong>xTicksToWait</strong> 表示的是，把命令写入命令队列的超时时间。命令队列可能已经满了，无法马上把命令写入队列里，可以等待一会。</p>
<p><strong>xTicksToWait</strong> 不是定时器本身的超时时间，不是定时器本身的”周期”。</p>
<p>创建定时器时，设置了它的周期(period)。<strong>xTimerStart()</strong> 函数是用来启动定时器。假设调用 <strong>xTimerStart()</strong> 的时刻是tX，定时器的周期是n，那么在<em>tX+n</em>时刻定时器的回调函数被调用。</p>
<p>如果定时器已经被启动，但是它的函数尚未被执行，再次执行 <strong>xTimerStart()</strong> 函数相当于执行 <strong>xTimerReset()</strong> ，重新设定它的启动时间。</p>
<h3 id="9-4、复位"><a href="#9-4、复位" class="headerlink" title="9.4、复位"></a>9.4、复位</h3><p>从定时器的状态转换图可以知道，使用 <strong>xTimerReset()</strong> 函数可以让定时器的状态从冬眠态转换为运行态，相当于使用 <strong>xTimerStart()</strong> 函数。</p>
<p>如果定时器已经处于运行态，使用 <strong>xTimerReset()</strong> 函数就相当于重新确定超时时间。假设调用 <strong>xTimerReset()</strong> 的时刻是tX，定时器的周期是n，那么<em>tX+n</em>就是重新确定的超时时间。</p>
<p>复位函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 复位定时器</span></span><br><span class="line"><span class="comment"> * xTimer: 哪个定时器</span></span><br><span class="line"><span class="comment"> * xTicksToWait: 超时时间</span></span><br><span class="line"><span class="comment"> * 返回值: pdFAIL表示&quot;复位命令&quot;在xTicksToWait个Tick内无法写入队列</span></span><br><span class="line"><span class="comment"> *        pdPASS表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xTimerReset</span><span class="params">( TimerHandle_t xTimer, TickType_t xTicksToWait )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 复位定时器(ISR版本)</span></span><br><span class="line"><span class="comment"> * xTimer: 哪个定时器</span></span><br><span class="line"><span class="comment"> * pxHigherPriorityTaskWoken: 向队列发出命令使得守护任务被唤醒,</span></span><br><span class="line"><span class="comment"> *                            如果守护任务的优先级比当前任务的高,</span></span><br><span class="line"><span class="comment"> *                            则&quot;*pxHigherPriorityTaskWoken = pdTRUE&quot;,</span></span><br><span class="line"><span class="comment"> *                            表示需要进行任务调度</span></span><br><span class="line"><span class="comment"> * 返回值: pdFAIL表示&quot;停止命令&quot;无法写入队列</span></span><br><span class="line"><span class="comment"> *        pdPASS表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xTimerResetFromISR</span><span class="params">(   TimerHandle_t xTimer,</span></span><br><span class="line"><span class="params">                                 BaseType_t *pxHigherPriorityTaskWoken )</span>;</span><br></pre></td></tr></table></figure>

<h3 id="9-5、修改周期"><a href="#9-5、修改周期" class="headerlink" title="9.5、修改周期"></a>9.5、修改周期</h3><p>从定时器的状态转换图可以知道，使用 <strong>xTimerChangePeriod()</strong> 函数，处理能修改它的周期外，还可以让定时器的状态从冬眠态转换为运行态。</p>
<p>修改定时器的周期时，会使用新的周期重新计算它的超时时间。假设调用 <strong>xTimerChangePeriod()</strong> 函数的时间tX，新的周期是n，则<em>tX+n</em>就是新的超时时间。</p>
<p>相关函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 修改定时器的周期</span></span><br><span class="line"><span class="comment"> * xTimer: 哪个定时器</span></span><br><span class="line"><span class="comment"> * xNewPeriod: 新周期</span></span><br><span class="line"><span class="comment"> * xTicksToWait: 超时时间, 命令写入队列的超时时间 </span></span><br><span class="line"><span class="comment"> * 返回值: pdFAIL表示&quot;修改周期命令&quot;在xTicksToWait个Tick内无法写入队列</span></span><br><span class="line"><span class="comment"> *        pdPASS表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xTimerChangePeriod</span><span class="params">(   TimerHandle_t xTimer,</span></span><br><span class="line"><span class="params">                                 TickType_t xNewPeriod,</span></span><br><span class="line"><span class="params">                                 TickType_t xTicksToWait )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 修改定时器的周期</span></span><br><span class="line"><span class="comment"> * xTimer: 哪个定时器</span></span><br><span class="line"><span class="comment"> * xNewPeriod: 新周期</span></span><br><span class="line"><span class="comment"> * pxHigherPriorityTaskWoken: 向队列发出命令使得守护任务被唤醒,</span></span><br><span class="line"><span class="comment"> *                            如果守护任务的优先级比当前任务的高,</span></span><br><span class="line"><span class="comment"> *                            则&quot;*pxHigherPriorityTaskWoken = pdTRUE&quot;,</span></span><br><span class="line"><span class="comment"> *                            表示需要进行任务调度</span></span><br><span class="line"><span class="comment"> * 返回值: pdFAIL表示&quot;修改周期命令&quot;在xTicksToWait个Tick内无法写入队列</span></span><br><span class="line"><span class="comment"> *        pdPASS表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xTimerChangePeriodFromISR</span><span class="params">( TimerHandle_t xTimer,</span></span><br><span class="line"><span class="params">                                      TickType_t xNewPeriod,</span></span><br><span class="line"><span class="params">                                      BaseType_t *pxHigherPriorityTaskWoken )</span>;</span><br></pre></td></tr></table></figure>

<h3 id="9-6、定时器ID"><a href="#9-6、定时器ID" class="headerlink" title="9.6、定时器ID"></a>9.6、定时器ID</h3><p>定时器的结构体如下，里面有一项 <strong>pvTimerID</strong> ，它就是定时器ID：</p>
<p><img src="http://photos.100ask.net/rtos-docs/FreeRTOS/DShanMCU-F103/chapter-16/image7.png" alt="img"></p>
<p>怎么使用定时器ID，完全由程序来决定：</p>
<ul>
<li>可以用来标记定时器，表示自己是什么定时器</li>
<li>可以用来保存参数，给回调函数使用</li>
</ul>
<p>它的初始值在创建定时器时由 <strong>xTimerCreate()</strong> 这类函数传入，后续可以使用这些函数来操作：</p>
<ul>
<li>更新ID：使用 <strong>vTimerSetTimerID()</strong> 函数</li>
<li>查询ID：查询 <strong>pvTimerGetTimerID()</strong> 函数</li>
</ul>
<p>这两个函数不涉及命令队列，它们是直接操作定时器结构体。</p>
<p>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获得定时器的ID</span></span><br><span class="line"><span class="comment"> * xTimer: 哪个定时器</span></span><br><span class="line"><span class="comment"> * 返回值: 定时器的ID</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">pvTimerGetTimerID</span><span class="params">( TimerHandle_t xTimer )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置定时器的ID</span></span><br><span class="line"><span class="comment"> * xTimer: 哪个定时器</span></span><br><span class="line"><span class="comment"> * pvNewID: 新ID</span></span><br><span class="line"><span class="comment"> * 返回值: 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vTimerSetTimerID</span><span class="params">( TimerHandle_t xTimer, <span class="type">void</span> *pvNewID )</span>;</span><br></pre></td></tr></table></figure>

<h1 id="十、中断管理-Interrupt-Management"><a href="#十、中断管理-Interrupt-Management" class="headerlink" title="十、中断管理(Interrupt Management)"></a>十、中断管理(Interrupt Management)</h1><p>在RTOS中，需要应对各类事件。这些事件很多时候是通过硬件中断产生，怎么处理中断呢？</p>
<p>假设当前系统正在运行Task1时，用户按下了按键，触发了按键中断。这个中断的处理流程如下：</p>
<ul>
<li>CPU跳到固定地址去执行代码，这个固定地址通常被称为中断向量，这个跳转时硬件实现的</li>
<li>执行代码做什么？<ul>
<li>保存现场：Task1被打断，需要先保存Task1的运行环境，比如各类寄存器的值</li>
<li>分辨中断、调用处理函数(这个函数就被称为ISR，interrupt service routine)</li>
<li>恢复现场：继续运行Task1，或者运行其他优先级更高的任务</li>
</ul>
</li>
</ul>
<p>你要注意到，ISR是在内核中被调用的，ISR执行过程中，用户的任务无法执行。ISR要尽量快，否则：</p>
<ul>
<li>其他低优先级的中断无法被处理：实时性无法保证</li>
<li>用户任务无法被执行：系统显得很卡顿</li>
</ul>
<p>如果这个硬件中断的处理，就是非常耗费时间呢？对于这类中断的处理就要分为2部分：</p>
<ul>
<li>ISR：尽快做些清理、记录工作，然后触发某个任务</li>
<li>任务：更复杂的事情放在任务中处理</li>
<li>所以：需要ISR和任务之间进行通信</li>
</ul>
<p>要在FreeRTOS中熟练使用中断，有几个原则要先说明：</p>
<ul>
<li>FreeRTOS把任务认为是硬件无关的，任务的优先级由程序员决定，任务何时运行由调度器决定</li>
<li>ISR虽然也是使用软件实现的，但是它被认为是硬件特性的一部分，因为它跟硬件密切相关<ul>
<li>何时执行？由硬件决定</li>
<li>哪个ISR被执行？由硬件决定</li>
</ul>
</li>
<li>ISR的优先级高于任务：即使是优先级最低的中断，它的优先级也高于任务。任务只有在没有中断的情况下，才能执行。</li>
</ul>
<p>本章涉及如下内容：</p>
<ul>
<li>FreeRTOS的哪些API函数能在ISR中使用</li>
<li>怎么把中断的处理分为两部分：ISR、任务</li>
<li>ISR和任务之间的通信</li>
</ul>
<h3 id="10-1、两套API函数"><a href="#10-1、两套API函数" class="headerlink" title="10.1、两套API函数"></a>10.1、两套API函数</h3><p>为什么需要两套API</p>
<p>在任务函数中，我们可以调用各类API函数，比如队列操作函数：xQueueSendToBack。但是在ISR中使用这个函数会导致问题，应该使用另一个函数：xQueueSendToBackFromISR，它的函数名含有后缀”FromISR”，表示”从ISR中给队列发送数据”。</p>
<p>FreeRTOS中很多API函数都有两套：一套在任务中使用，另一套在ISR中使用。后者的函数名含有”FromISR”后缀。</p>
<p>为什么要引入两套API函数？</p>
<ul>
<li>很多API函数会导致任务计入阻塞状态：<ul>
<li>运行这个函数的 <strong>任务</strong> 进入阻塞状态</li>
<li>比如写队列时，如果队列已满，可以进入阻塞状态等待一会</li>
</ul>
</li>
<li>ISR调用API函数时，ISR不是”任务”，ISR不能进入阻塞状态</li>
<li>所以，在任务中、在ISR中，这些函数的功能是有差别的</li>
</ul>
<p>为什么不使用同一套函数，比如在函数里面分辨当前调用者是任务还是ISR呢？示例代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xQueueSend</span><span class="params">(...)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (is_in_isr())</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="comment">/* 把数据放入队列 */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 不管是否成功都直接返回 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">/* 在任务中 */</span></span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="comment">/* 把数据放入队列 */</span></span><br><span class="line">        <span class="comment">/* 不成功就等待一会再重试 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FreeRTOS使用两套函数，而不是使用一套函数，是因为有如下好处：</p>
<ul>
<li>使用同一套函数的话，需要增加额外的判断代码、增加额外的分支，是的函数更长、更复杂、难以测试</li>
<li>在任务、ISR中调用时，需要的参数不一样，比如：<ul>
<li>在任务中调用：需要指定超时时间，表示如果不成功就阻塞一会</li>
<li>在ISR中调用：不需要指定超时时间，无论是否成功都要即刻返回</li>
<li>如果强行把两套函数揉在一起，会导致参数臃肿、无效</li>
</ul>
</li>
<li>移植FreeRTOS时，还需要提供监测上下文的函数，比如 <strong>is_in_isr()</strong></li>
<li>有些处理器架构没有办法轻易分辨当前是处于任务中，还是处于ISR中，就需要额外添加更多、更复杂的代码</li>
</ul>
<p>使用两套函数可以让程序更高效，但是也有一些缺点，比如你要使用第三方库函数时，即会在任务中调用它，也会在ISR总调用它。这个第三方库函数用到了FreeRTOS的API函数，你无法修改库函数。这个问题可以解决：</p>
<ul>
<li>把中断的处理推迟到任务中进行(Defer interrupt processing)，在任务中调用库函数</li>
<li>尝试在库函数中使用”FromISR”函数：<ul>
<li>在任务中、在ISR中都可以调用”FromISR”函数</li>
<li>反过来就不行，非FromISR函数无法在ISR中使用</li>
</ul>
</li>
<li>第三方库函数也许会提供OS抽象层，自行判断当前环境是在任务还是在ISR中，分别调用不同的函数</li>
</ul>
<p>两套API函数列表</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>在任务中</th>
<th>在ISR中</th>
</tr>
</thead>
<tbody><tr>
<td>队列(queue)</td>
<td>xQueueSendToBack</td>
<td>xQueueSendToBackFromISR</td>
</tr>
<tr>
<td>xQueueSendToFront</td>
<td>xQueueSendToFrontFromISR</td>
<td></td>
</tr>
<tr>
<td>xQueueReceive</td>
<td>xQueueReceiveFromISR</td>
<td></td>
</tr>
<tr>
<td>xQueueOverwrite</td>
<td>xQueueOverwriteFromISR</td>
<td></td>
</tr>
<tr>
<td>xQueuePeek</td>
<td>xQueuePeekFromISR</td>
<td></td>
</tr>
<tr>
<td>信号量(semaphore)</td>
<td>xSemaphoreGive</td>
<td>xSemaphoreGiveFromISR</td>
</tr>
<tr>
<td>xSemaphoreTake</td>
<td>xSemaphoreTakeFromISR</td>
<td></td>
</tr>
<tr>
<td>事件组(event group)</td>
<td>xEventGroupSetBits</td>
<td>xEventGroupSetBitsFromISR</td>
</tr>
<tr>
<td>xEventGroupGetBits</td>
<td>xEventGroupGetBitsFromISR</td>
<td></td>
</tr>
<tr>
<td>任务通知(task notification)</td>
<td>xTaskNotifyGive</td>
<td>vTaskNotifyGiveFromISR</td>
</tr>
<tr>
<td>xTaskNotify</td>
<td>xTaskNotifyFromISR</td>
<td></td>
</tr>
<tr>
<td>软件定时器(software timer)</td>
<td>xTimerStart</td>
<td>xTimerStartFromISR</td>
</tr>
<tr>
<td>xTimerStop</td>
<td>xTimerStopFromISR</td>
<td></td>
</tr>
<tr>
<td>xTimerReset</td>
<td>xTimerResetFromISR</td>
<td></td>
</tr>
<tr>
<td>xTimerChangePeriod</td>
<td>xTimerChangePeriodFromISR</td>
<td></td>
</tr>
</tbody></table>
<p>xHigherPriorityTaskWoken参数</p>
<p>xHigherPriorityTaskWoken的含义是：是否有更高优先级的任务被唤醒了。如果为pdTRUE，则意味着后面要进行任务切换。</p>
<p>还是以写队列为例。</p>
<p>任务A调用 <strong>xQueueSendToBack()</strong> 写队列，有几种情况发生：</p>
<ul>
<li>队列满了，任务A阻塞等待，另一个任务B运行</li>
<li>队列没满，任务A成功写入队列，但是它导致另一个任务B被唤醒，任务B的优先级更高：任务B先运行</li>
<li>队列没满，任务A成功写入队列，即刻返回</li>
</ul>
<p>可以看到，在任务中调用API函数可能导致任务阻塞、任务切换，这叫做”context switch”，上下文切换。这个函数可能很长时间才返回，在函数的内部实现了任务切换。</p>
<p><strong>xQueueSendToBackFromISR()</strong> 函数也可能导致任务切换，但是不会在函数内部进行切换，而是返回一个参数：表示是否需要切换，函数原型与用法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 往队列尾部写入数据，此函数可以在中断函数中使用，不可阻塞</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xQueueSendToBackFromISR</span><span class="params">(</span></span><br><span class="line"><span class="params">                                      QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                                      <span class="type">const</span> <span class="type">void</span> *pvItemToQueue,</span></span><br><span class="line"><span class="params">                                      BaseType_t *pxHigherPriorityTaskWoken</span></span><br><span class="line"><span class="params">                                   )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 用法示例 */</span></span><br><span class="line"></span><br><span class="line">BaseType_t xHigherPriorityTaskWoken = pdFALSE;</span><br><span class="line">xQueueSendToBackFromISR(xQueue, pvItemToQueue, &amp;xHigherPriorityTaskWoken);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (xHigherPriorityTaskWoken == pdTRUE)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 任务切换 */</span>    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pxHigherPriorityTaskWoken参数，就是用来保存函数的结果：是否需要切换</p>
<ul>
<li>*pxHigherPriorityTaskWoken等于pdTRUE：函数的操作导致更高优先级的任务就绪了，ISR应该进行任务切换</li>
<li>*pxHigherPriorityTaskWoken等于pdFALSE：没有进行任务切换的必要</li>
</ul>
<p>为什么不在”FromISR”函数内部进行任务切换，而只是标记一下而已呢？为了效率！示例代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">XXX_ISR</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        xQueueSendToBackFromISR(...); <span class="comment">/* 被多次调用 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ISR中有可能多次调用”FromISR”函数，如果在”FromISR”内部进行任务切换，会浪费时间。解决方法是：</p>
<ul>
<li>在”FromISR”中标记是否需要切换</li>
<li>在ISR返回之前再进行任务切换</li>
<li>示例代码如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">XXX_ISR</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    BaseType_t xHigherPriorityTaskWoken = pdFALSE;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        xQueueSendToBackFromISR(..., &amp;xHigherPriorityTaskWoken); <span class="comment">/* 被多次调用 */</span></span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/* 最后再决定是否进行任务切换 */</span></span><br><span class="line">    <span class="keyword">if</span> (xHigherPriorityTaskWoken == pdTRUE)</span><br><span class="line">	&#123;</span><br><span class="line">    	<span class="comment">/* 任务切换 */</span>    </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述的例子很常见，比如UART中断：在UART的ISR中读取多个字符，发现收到回车符时才进行任务切换。</p>
<p>在ISR中调用API时不进行任务切换，而只是在”xHigherPriorityTaskWoken”中标记一下，除了效率，还有多种好处：</p>
<ul>
<li>效率高：避免不必要的任务切换</li>
<li>让ISR更可控：中断随机产生，在API中进行任务切换的话，可能导致问题更复杂</li>
<li>可移植性</li>
<li>在Tick中断中，调用 <strong>vApplicationTickHook()</strong> ：它运行与ISR，只能使用”FromISR”的函数</li>
</ul>
<p>使用”FromISR”函数时，如果不想使用xHigherPriorityTaskWoken参数，可以设置为NULL。</p>
<p>怎么切换任务</p>
<p>FreeRTOS的ISR函数中，使用两个宏进行任务切换：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">	portEND_SWITCHING_ISR( xHigherPriorityTaskWoken );</span><br><span class="line">或</span><br><span class="line">	portYIELD_FROM_ISR( xHigherPriorityTaskWoken );</span><br></pre></td></tr></table></figure>

<p>这两个宏做的事情是完全一样的，在老版本的FreeRTOS中，</p>
<ul>
<li><strong>portEND_SWITCHING_ISR</strong> 使用汇编实现</li>
<li><strong>portYIELD_FROM_ISR</strong> 使用C语言实现</li>
</ul>
<p>新版本都统一使用<strong>portYIELD_FROM_ISR</strong>。</p>
<p>使用示例如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">XXX_ISR</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    BaseType_t xHigherPriorityTaskWoken = pdFALSE;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        xQueueSendToBackFromISR(..., &amp;xHigherPriorityTaskWoken); <span class="comment">/* 被多次调用 */</span></span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/* 最后再决定是否进行任务切换 </span></span><br><span class="line"><span class="comment">     * xHigherPriorityTaskWoken为pdTRUE时才切换</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-2、中断的延迟处理"><a href="#10-2、中断的延迟处理" class="headerlink" title="10.2、中断的延迟处理"></a>10.2、中断的延迟处理</h3><p>前面讲过，ISR要尽量快，否则：</p>
<ul>
<li>其他低优先级的中断无法被处理：实时性无法保证</li>
<li>用户任务无法被执行：系统显得很卡顿</li>
<li>如果运行中断嵌套，这会更复杂，ISR越快执行约有助于中断嵌套</li>
</ul>
<p>如果这个硬件中断的处理，就是非常耗费时间呢？对于这类中断的处理就要分为2部分：</p>
<ul>
<li>ISR：尽快做些清理、记录工作，然后触发某个任务</li>
<li>任务：更复杂的事情放在任务中处理</li>
</ul>
<p>这种处理方式叫”中断的延迟处理”(Deferring interrupt processing)，处理流程如下图所示：</p>
<ul>
<li>t1：任务1运行，任务2阻塞</li>
<li>t2：发生中断，</li>
<li>该中断的ISR函数被执行，任务1被打断</li>
<li>ISR函数要尽快能快速地运行，它做一些必要的操作(比如清除中断)，然后唤醒任务2</li>
<li>t3：在创建任务时设置任务2的优先级比任务1高(这取决于设计者)，所以ISR返回后，运行的是任务2，它要完成中断的处理。任务2就被称为”deferred processing task”，中断的延迟处理任务。</li>
<li>t4：任务2处理完中断后，进入阻塞态以等待下一个中断，任务1重新运行</li>
</ul>
<p><img src="http://photos.100ask.net/rtos-docs/FreeRTOS/DShanMCU-F103/chapter-17/image1.png" alt="img"></p>
<h3 id="10-3、中断与任务间的通信"><a href="#10-3、中断与任务间的通信" class="headerlink" title="10.3、中断与任务间的通信"></a>10.3、中断与任务间的通信</h3><p>前面讲解过的队列、信号量、互斥量、事件组、任务通知等等方法，都可使用。</p>
<p>要注意的是，在ISR中使用的函数要有”FromISR”后缀。</p>
<h3 id="10-4、示例-优化实时性"><a href="#10-4、示例-优化实时性" class="headerlink" title="10.4、示例: 优化实时性"></a>10.4、示例: 优化实时性</h3><p>本节代码为：29_fromisr_game，主要看DshanMCU-F103\driver_ir_receiver.c。</p>
<p>以前，在中断函数里写队列时，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">150</span> <span class="type">static</span> <span class="type">void</span> <span class="title function_">DispatchKey</span><span class="params">(<span class="keyword">struct</span> ir_data *pidata)</span></span><br><span class="line"></span><br><span class="line">151 &#123;</span><br><span class="line"></span><br><span class="line"><span class="number">152</span> <span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line"></span><br><span class="line"><span class="number">153</span>   <span class="keyword">extern</span> QueueHandle_t g_xQueueCar1;</span><br><span class="line"></span><br><span class="line"><span class="number">154</span>   <span class="keyword">extern</span> QueueHandle_t g_xQueueCar2;</span><br><span class="line"></span><br><span class="line"><span class="number">155</span>   <span class="keyword">extern</span> QueueHandle_t g_xQueueCar3;</span><br><span class="line"></span><br><span class="line"><span class="number">156</span>   xQueueSendFromISR(g_xQueueCar1, pidata, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">157</span>   xQueueSendFromISR(g_xQueueCar2, pidata, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">158</span>   xQueueSendFromISR(g_xQueueCar3, pidata, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">159</span> <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="number">160</span>   <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="number">161</span>    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g_queue_cnt; i++)</span><br><span class="line"></span><br><span class="line"><span class="number">162</span>    &#123;</span><br><span class="line"></span><br><span class="line"><span class="number">163</span>        xQueueSendFromISR(g_xQueues[i], pidata, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">164</span>    &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">165</span> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="number">166</span> &#125;</span><br></pre></td></tr></table></figure>

<p>假设当前运行的是任务A，它的优先级比较低，在它运行过程中发生了中断，中断函数调用了DispatchKey函数写了队列，使得任务B被唤醒了。任务B的优先级比较高，它应该在中断执行完后马上就能运行。但是上述代码无法实现这个目标，xQueueSendFromISR函数会把任务B调整为就绪态，但是不会发起一次调度。</p>
<p>需要如下修改代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">150</span> <span class="type">static</span> <span class="type">void</span> <span class="title function_">DispatchKey</span><span class="params">(<span class="keyword">struct</span> ir_data *pidata)</span></span><br><span class="line"></span><br><span class="line">151 &#123;</span><br><span class="line"></span><br><span class="line"><span class="number">152</span> <span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line"></span><br><span class="line"><span class="number">153</span>   <span class="keyword">extern</span> QueueHandle_t g_xQueueCar1;</span><br><span class="line"></span><br><span class="line"><span class="number">154</span>   <span class="keyword">extern</span> QueueHandle_t g_xQueueCar2;</span><br><span class="line"></span><br><span class="line"><span class="number">155</span>   <span class="keyword">extern</span> QueueHandle_t g_xQueueCar3;</span><br><span class="line"></span><br><span class="line"><span class="number">156</span>   xQueueSendFromISR(g_xQueueCar1, pidata, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">157</span>    xQueueSendFromISR(g_xQueueCar2, pidata, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">158</span>    xQueueSendFromISR(g_xQueueCar3, pidata, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">159</span> <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="number">160</span>    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="number">161</span>   BaseType_t xHigherPriorityTaskWoken = pdFALSE;</span><br><span class="line"></span><br><span class="line"><span class="number">162</span>    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g_queue_cnt; i++)</span><br><span class="line"></span><br><span class="line"><span class="number">163</span>    &#123;</span><br><span class="line"></span><br><span class="line"><span class="number">164</span>        xQueueSendFromISR(g_xQueues[i], pidata, &amp;xHigherPriorityTaskWoken);</span><br><span class="line"></span><br><span class="line"><span class="number">165</span>    &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">166</span>   portYIELD_FROM_ISR(xHigherPriorityTaskWoken);</span><br><span class="line"></span><br><span class="line"><span class="number">167</span> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="number">168</span> &#125;</span><br></pre></td></tr></table></figure>

<p>在第164行传入一个变量的地址：&amp;xHigherPriorityTaskWoken，它的初始值是pdFALSE，表示无需发起调度。如果xQueueSendFromISR函数发现唤醒了更高优先级的任务，那么就会把这个变量设置为pdTRUE。</p>
<p>第166行，如果xHigherPriorityTaskWoken为pdTRUE，它就会发起一次调度。</p>
<p>本程序上机时，我们感觉不到有什么不同。</p>
<h1 id="十一、资源管理-Resource-Management"><a href="#十一、资源管理-Resource-Management" class="headerlink" title="十一、资源管理(Resource Management)"></a>十一、资源管理(Resource Management)</h1><p>在前面讲解互斥量时，引入过临界资源的概念。在前面课程里，已经实现了临界资源的互斥访问。</p>
<p>本章节的内容比较少，只是引入两个功能：屏蔽&#x2F;使能中断、暂停&#x2F;恢复调度器。</p>
<p>要独占式地访问临界资源，有3种方法：</p>
<ul>
<li>公平竞争：比如使用互斥量，谁先获得互斥量谁就访问临界资源，这部分内容前面讲过。</li>
<li>谁要跟我抢，我就灭掉谁：<ul>
<li>中断要跟我抢？我屏蔽中断</li>
<li>其他任务要跟我抢？我禁止调度器，不运行任务切换</li>
</ul>
</li>
</ul>
<h3 id="11-1、屏蔽中断"><a href="#11-1、屏蔽中断" class="headerlink" title="11.1、屏蔽中断"></a>11.1、屏蔽中断</h3><p>屏蔽中断有两套宏：任务中使用、ISR中使用：</p>
<ul>
<li>任务中使用：<strong>taskENTER_CRITICA()&#x2F;taskEXIT_CRITICAL()</strong></li>
<li>ISR中使用：<strong>taskENTER_CRITICAL_FROM_ISR()&#x2F;taskEXIT_CRITICAL_FROM_ISR()</strong></li>
</ul>
<p>11.2、在任务中屏蔽中断</p>
<p>在任务中屏蔽中断的示例代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在任务中，当前时刻中断是使能的</span></span><br><span class="line"><span class="comment"> * 执行这句代码后，屏蔽中断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">taskENTER_CRITICAL();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 访问临界资源 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 重新使能中断 */</span></span><br><span class="line">taskEXIT_CRITICAL();</span><br></pre></td></tr></table></figure>

<p>在 <strong>taskENTER_CRITICA()&#x2F;taskEXIT_CRITICAL()</strong> 之间：</p>
<ul>
<li><p>低优先级的中断被屏蔽了：优先级低于、等于 <strong>configMAX_SYSCALL_INTERRUPT_PRIORITY</strong></p>
</li>
<li><p>高优先级的中断可以产生：优先级高于</p>
<p>configMAX_SYSCALL_INTERRUPT_PRIORITY</p>
<ul>
<li>但是，这些中断ISR里，不允许使用FreeRTOS的API函数</li>
</ul>
</li>
<li><p>任务调度依赖于中断、依赖于API函数，所以：这两段代码之间，不会有任务调度产生</p>
</li>
</ul>
<p>这套 <strong>taskENTER_CRITICA()&#x2F;taskEXIT_CRITICAL()</strong> 宏，是可以递归使用的，它的内部会记录嵌套的深度，只有嵌套深度变为0时，调用 <strong>taskEXIT_CRITICAL()</strong> 才会重新使能中断。</p>
<p>使用 <strong>taskENTER_CRITICA()&#x2F;taskEXIT_CRITICAL()</strong> 来访问临界资源是很粗鲁的方法：</p>
<ul>
<li>中断无法正常运行</li>
<li>任务调度无法进行</li>
<li>所以，之间的代码要尽可能快速地执行</li>
</ul>
<h3 id="11-2、在ISR中屏蔽中断"><a href="#11-2、在ISR中屏蔽中断" class="headerlink" title="11.2、在ISR中屏蔽中断"></a>11.2、在ISR中屏蔽中断</h3><p>要使用含有”FROM_ISR”后缀的宏，示例代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vAnInterruptServiceRoutine</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 用来记录当前中断是否使能 */</span></span><br><span class="line">    UBaseType_t uxSavedInterruptStatus;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 在ISR中，当前时刻中断可能是使能的，也可能是禁止的</span></span><br><span class="line"><span class="comment">     * 所以要记录当前状态, 后面要恢复为原先的状态</span></span><br><span class="line"><span class="comment">     * 执行这句代码后，屏蔽中断</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 访问临界资源 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 恢复中断状态 */</span></span><br><span class="line">    taskEXIT_CRITICAL_FROM_ISR( uxSavedInterruptStatus );</span><br><span class="line">    <span class="comment">/* 现在，当前ISR可以被更高优先级的中断打断了 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <strong>taskENTER_CRITICA_FROM_ISR()&#x2F;taskEXIT_CRITICAL_FROM_ISR()</strong> 之间：</p>
<ul>
<li><p>低优先级的中断被屏蔽了：优先级低于、等于 <strong>configMAX_SYSCALL_INTERRUPT_PRIORITY</strong></p>
</li>
<li><p>高优先级的中断可以产生：优先级高于</p>
<p>configMAX_SYSCALL_INTERRUPT_PRIORITY</p>
<ul>
<li>但是，这些中断ISR里，不允许使用FreeRTOS的API函数</li>
</ul>
</li>
<li><p>任务调度依赖于中断、依赖于API函数，所以：这两段代码之间，不会有任务调度产生</p>
</li>
</ul>
<h3 id="11-3、暂停调度器"><a href="#11-3、暂停调度器" class="headerlink" title="11.3、暂停调度器"></a>11.3、暂停调度器</h3><p>如果有别的任务来跟你竞争临界资源，你可以把中断关掉：这当然可以禁止别的任务运行，但是这代价太大了。它会影响到中断的处理。</p>
<p>如果只是禁止别的任务来跟你竞争，不需要关中断，暂停调度器就可以了：在这期间，中断还是可以发生、处理。</p>
<p>使用这2个函数来暂停、恢复调度器：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 暂停调度器 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vTaskSuspendAll</span><span class="params">( <span class="type">void</span> )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 恢复调度器</span></span><br><span class="line"><span class="comment"> * 返回值: pdTRUE表示在暂定期间有更高优先级的任务就绪了</span></span><br><span class="line"><span class="comment"> *        可以不理会这个返回值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xTaskResumeAll</span><span class="params">( <span class="type">void</span> )</span>;</span><br></pre></td></tr></table></figure>

<p>示例代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vTaskSuspendScheduler();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 访问临界资源 */</span></span><br><span class="line"></span><br><span class="line">xTaskResumeScheduler();</span><br></pre></td></tr></table></figure>

<p>这套 <strong>vTaskSuspendScheduler()&#x2F;xTaskResumeScheduler()</strong> 宏，是可以递归使用的，它的内部会记录嵌套的深度，只有嵌套深度变为0时，调用 <strong>taskEXIT_CRITICAL()</strong> 才会重新使能中断。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">WangTao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/09/01/FreeRTOS/FrreeRTOS%E7%AC%94%E8%AE%B0/">http://example.com/2024/09/01/FreeRTOS/FrreeRTOS%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">无限进步</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/FreeRTOS/">FreeRTOS</a></div><div class="post-share"><div class="social-share" data-image="https://pic1.imgdb.cn/item/63a83a5408b68301634bd72b.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/04/10/STM32%E5%9F%BA%E7%A1%80/C%E8%AF%AD%E8%A8%80/" title="C语言笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">C语言笔记</div></div><div class="info-2"><div class="info-item-1">一、从源代码到exe知识点： 从源代码到exe要经过五个时期，分别为预处理期、编译期、汇编期、连接期和执行期。在预处理期，就是程序员在编写代码的过程。编译期中编译器将源代码变为汇编语言，汇编语言是计算机语言的助记符号。汇编期中汇编器将汇编语言变为机器语言.obj，也就是计算机能够识别的01指令，机器最终执行的就是机器语言.obj，也称为目标文件。连接期就是将库函数（头文件）与所有的机器语言进行打包。最终在执行期将打包好的文件变为exe可执行文件。如果出现语法错误，那就是在编译期出现了编译错误。如果产生LNK连接错误就是在连接期出现了问题，可能是找不到头文件造成的，也可能是写错了main函数，或者在一个项目中没有或者出现多个main函数。 二、基本数据类型 知识点： 基本数据类型可以分为整型、字符型和浮点型三大类，其中整型包括short,int,long,long long 4小类；字符型包括char一个小类；浮点型包括float,double,long double 3小类。不同类型的字节数：char  1   short  2   int  4   long  4  ...</div></div></div></a><a class="pagination-related" href="/2024/10/10/STM32%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/%E6%97%A0%E4%BA%BA%E6%9C%BA%E4%B8%B2%E7%BA%A7PID/" title="无人机串级PID"><img class="cover" src="https://pic1.imgdb.cn/item/63a83a5408b68301634bd72b.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">无人机串级PID</div></div><div class="info-2"><div class="info-item-1">无人机串级PID123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &quot;pid.h&quot;#include &quot;myMath.h&quot;	/************************************************************** *批量复位PID函数 * @param[in]  * @param[out]  * @return      ***************************************************************/	void pidRest(PidObject **pid,const uint8_t len)&#123;	uint8_t i;	for(i=0;i&lt;len;i++)	&#123;	  	pid[i]-&gt;integ = 0;	...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://pic1.imgdb.cn/item/67dfb24188c538a9b5c50a54.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">WangTao</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://space.bilibili.com/449096702"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/18232290771" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="https://space.bilibili.com/449096702" target="_blank" title="Bilibili"><i class="fab fa-youtube" style="color: #24292e;"></i></a><a class="social-icon" href="https://pic.imgdb.cn/item/66f0ca68f21886ccc03a5df7.jpg" target="_blank" title="Wechat"><i class="fab fa-weixin" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">无线进步！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81FreeRTOS%E6%BA%90%E7%A0%81%E6%A6%82%E8%BF%B0"><span class="toc-text">一、FreeRTOS源码概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%85%A5%E5%8F%A3%E5%87%BD%E6%95%B0"><span class="toc-text">1、入口函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">2、数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%8F%98%E9%87%8F%E5%90%8D"><span class="toc-text">3、变量名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%87%BD%E6%95%B0%E5%90%8D"><span class="toc-text">4、函数名</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">二、内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%A0%86%E5%92%8C%E6%A0%88"><span class="toc-text">1、堆和栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81Heap%E7%9B%B8%E5%85%B3%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-text">2、Heap相关的函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86"><span class="toc-text">三、任务管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%88%9B%E5%BB%BA%E4%BB%BB%E5%8A%A1"><span class="toc-text">1、创建任务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1%E3%80%81%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-text">1.1、示例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2%E3%80%81%E5%87%BD%E6%95%B0%E8%A7%A3%E6%9E%90"><span class="toc-text">1.2、函数解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3%E3%80%81%E4%BD%BF%E7%94%A8%E4%BB%BB%E5%8A%A1%E5%8F%82%E6%95%B0"><span class="toc-text">1.3、使用任务参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%A0%E9%99%A4"><span class="toc-text">2、任务的删除</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1%E3%80%81%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-text">2.1、示例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2%E3%80%81%E5%87%BD%E6%95%B0%E8%A7%A3%E6%9E%90%EF%BC%9A"><span class="toc-text">2.2、函数解析：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8CTick"><span class="toc-text">3、优先级和Tick</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1%E3%80%81%E4%BC%98%E5%85%88%E7%BA%A7%E5%AE%9E%E9%AA%8C"><span class="toc-text">3.1、优先级实验</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2%E3%80%81%E4%BF%AE%E6%94%B9%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-text">3.2、修改优先级</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E4%BB%BB%E5%8A%A1%E7%8A%B6%E6%80%81"><span class="toc-text">4、任务状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E4%BB%BB%E5%8A%A1%E6%9A%82%E5%81%9C%E4%B8%8E%E6%81%A2%E5%A4%8D"><span class="toc-text">5、任务暂停与恢复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E4%B8%A4%E4%B8%AAdelay%E5%87%BD%E6%95%B0"><span class="toc-text">6、两个delay函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5"><span class="toc-text">四、同步与互斥</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%A6%82%E5%BF%B5"><span class="toc-text">1、概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%B8%A4%E4%B8%AA%E6%9C%89%E7%BC%BA%E9%99%B7%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-text">2、两个有缺陷的方法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81FreeRTOS%E6%8F%90%E4%BE%9B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">3、FreeRTOS提供的方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81-%E9%98%9F%E5%88%97%E5%87%BD%E6%95%B0"><span class="toc-text">五、 队列函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%88%9B%E5%BB%BA"><span class="toc-text">1、创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%A4%8D%E4%BD%8D"><span class="toc-text">2、复位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%88%A0%E9%99%A4"><span class="toc-text">3、删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%86%99%E9%98%9F%E5%88%97"><span class="toc-text">4、写队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E8%AF%BB%E9%98%9F%E5%88%97"><span class="toc-text">5、读队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E6%9F%A5%E8%AF%A2"><span class="toc-text">6、查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E8%A6%86%E7%9B%96-%E5%81%B7%E7%9C%8B"><span class="toc-text">7、覆盖&#x2F;偷看</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%87%BD%E6%95%B0"><span class="toc-text">六、信号量函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1%E3%80%81-%E5%88%9B%E5%BB%BA"><span class="toc-text">6.1、 创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2%E3%80%81%E5%88%A0%E9%99%A4"><span class="toc-text">6.2、删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3%E3%80%81give-take"><span class="toc-text">6.3、give&#x2F;take</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E4%BA%92%E6%96%A5%E9%87%8F%E5%87%BD%E6%95%B0"><span class="toc-text">七、互斥量函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1%E3%80%81%E5%88%9B%E5%BB%BA"><span class="toc-text">7.1、创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2%E3%80%81%E5%85%B6%E4%BB%96%E5%87%BD%E6%95%B0"><span class="toc-text">7.2、其他函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E4%BA%8B%E4%BB%B6%E7%BB%84%E5%87%BD%E6%95%B0"><span class="toc-text">八、事件组函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1%E3%80%81%E5%88%9B%E5%BB%BA"><span class="toc-text">8.1、创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2%E3%80%81%E5%88%A0%E9%99%A4"><span class="toc-text">8.2、删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3%E3%80%81%E8%AE%BE%E7%BD%AE%E4%BA%8B%E4%BB%B6"><span class="toc-text">8.3、设置事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4%E3%80%81%E7%AD%89%E5%BE%85%E4%BA%8B%E4%BB%B6"><span class="toc-text">8.4、等待事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5%E3%80%81%E5%90%8C%E6%AD%A5%E7%82%B9"><span class="toc-text">8.5、同步点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-6%E3%80%81%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A5"><span class="toc-text">8.6、任务通知</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E8%BD%AF%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-text">九、软件定时器的函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1%E3%80%81%E5%88%9B%E5%BB%BA"><span class="toc-text">9.1、创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2%E3%80%81%E5%88%A0%E9%99%A4"><span class="toc-text">9.2、删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3%E3%80%81%E5%90%AF%E5%8A%A8-%E5%81%9C%E6%AD%A2"><span class="toc-text">9.3、启动&#x2F;停止</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4%E3%80%81%E5%A4%8D%E4%BD%8D"><span class="toc-text">9.4、复位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-5%E3%80%81%E4%BF%AE%E6%94%B9%E5%91%A8%E6%9C%9F"><span class="toc-text">9.5、修改周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-6%E3%80%81%E5%AE%9A%E6%97%B6%E5%99%A8ID"><span class="toc-text">9.6、定时器ID</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E4%B8%AD%E6%96%AD%E7%AE%A1%E7%90%86-Interrupt-Management"><span class="toc-text">十、中断管理(Interrupt Management)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1%E3%80%81%E4%B8%A4%E5%A5%97API%E5%87%BD%E6%95%B0"><span class="toc-text">10.1、两套API函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2%E3%80%81%E4%B8%AD%E6%96%AD%E7%9A%84%E5%BB%B6%E8%BF%9F%E5%A4%84%E7%90%86"><span class="toc-text">10.2、中断的延迟处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3%E3%80%81%E4%B8%AD%E6%96%AD%E4%B8%8E%E4%BB%BB%E5%8A%A1%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-text">10.3、中断与任务间的通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4%E3%80%81%E7%A4%BA%E4%BE%8B-%E4%BC%98%E5%8C%96%E5%AE%9E%E6%97%B6%E6%80%A7"><span class="toc-text">10.4、示例: 优化实时性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86-Resource-Management"><span class="toc-text">十一、资源管理(Resource Management)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1%E3%80%81%E5%B1%8F%E8%94%BD%E4%B8%AD%E6%96%AD"><span class="toc-text">11.1、屏蔽中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2%E3%80%81%E5%9C%A8ISR%E4%B8%AD%E5%B1%8F%E8%94%BD%E4%B8%AD%E6%96%AD"><span class="toc-text">11.2、在ISR中屏蔽中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3%E3%80%81%E6%9A%82%E5%81%9C%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="toc-text">11.3、暂停调度器</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/04/01/YOLO/ArUco%E5%AE%9A%E4%BD%8D/" title="ArUco定位"><img src="https://pic1.imgdb.cn/item/63a83a5408b68301634bd72b.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ArUco定位"/></a><div class="content"><a class="title" href="/2025/04/01/YOLO/ArUco%E5%AE%9A%E4%BD%8D/" title="ArUco定位">ArUco定位</a><time datetime="2025-03-31T16:00:00.000Z" title="发表于 2025-04-01 00:00:00">2025-04-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/20/ROS/URDF%E4%B8%8ETF%E8%BD%AC%E6%8D%A2/" title="URDF与TF转化"><img src="https://pic1.imgdb.cn/item/63a83a5408b68301634bd72b.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="URDF与TF转化"/></a><div class="content"><a class="title" href="/2025/03/20/ROS/URDF%E4%B8%8ETF%E8%BD%AC%E6%8D%A2/" title="URDF与TF转化">URDF与TF转化</a><time datetime="2025-03-19T16:00:00.000Z" title="发表于 2025-03-20 00:00:00">2025-03-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/18/STM32%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/%E4%B8%A4%E8%BD%AE%E5%B7%AE%E9%80%9F%E8%BF%90%E5%8A%A8%E5%AD%A6%E8%A7%A3%E7%AE%97/" title="两轮差速运动学解算"><img src="https://pic1.imgdb.cn/item/63a83a5408b68301634bd72b.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="两轮差速运动学解算"/></a><div class="content"><a class="title" href="/2025/03/18/STM32%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/%E4%B8%A4%E8%BD%AE%E5%B7%AE%E9%80%9F%E8%BF%90%E5%8A%A8%E5%AD%A6%E8%A7%A3%E7%AE%97/" title="两轮差速运动学解算">两轮差速运动学解算</a><time datetime="2025-03-17T16:00:00.000Z" title="发表于 2025-03-18 00:00:00">2025-03-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/15/ROS/STM32%E4%B8%8EROS%E9%80%9A%E4%BF%A1/" title="STM32与ROS通信"><img src="https://pic1.imgdb.cn/item/63a83a5408b68301634bd72b.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="STM32与ROS通信"/></a><div class="content"><a class="title" href="/2025/03/15/ROS/STM32%E4%B8%8EROS%E9%80%9A%E4%BF%A1/" title="STM32与ROS通信">STM32与ROS通信</a><time datetime="2025-03-14T16:00:00.000Z" title="发表于 2025-03-15 00:00:00">2025-03-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/01/STM32%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/%E4%B8%B2%E5%8F%A3%E6%8E%A5%E6%94%B6%E5%AD%97%E7%AC%A6%E4%B8%B2/" title="串口接收字符串"><img src="https://pic1.imgdb.cn/item/63a83a5408b68301634bd72b.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="串口接收字符串"/></a><div class="content"><a class="title" href="/2025/03/01/STM32%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/%E4%B8%B2%E5%8F%A3%E6%8E%A5%E6%94%B6%E5%AD%97%E7%AC%A6%E4%B8%B2/" title="串口接收字符串">串口接收字符串</a><time datetime="2025-02-28T16:00:00.000Z" title="发表于 2025-03-01 00:00:00">2025-03-01</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent;"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2025 By WangTao</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>